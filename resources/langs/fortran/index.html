<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ACM Computing Seminar Fortran Guide</title>
<!-- 2017-10-02 Mon 20:35 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Joseph P. McKenna" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css">
<link rel="stylesheet" type="text/css" href="../css/fortran.css">
<script src="../js/main.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=Tex-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ACM Computing Seminar Fortran Guide</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. About the language</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Getting started</a>
<ul>
<li><a href="#sec-2-1">2.1. Text editor</a></li>
<li><a href="#sec-2-2">2.2. Compiler</a></li>
<li><a href="#sec-2-3">2.3. Writing and compiling a program</a>
<ul>
<li><a href="#sec-2-3-1">2.3.1. Hello world</a></li>
<li><a href="#sec-2-3-2">2.3.2. Template</a></li>
</ul>
</li>
<li><a href="#sec-2-4">2.4. Exercises</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Data types</a>
<ul>
<li><a href="#sec-3-1">3.1. The <code>logical</code> type</a></li>
<li><a href="#sec-3-2">3.2. The <code>integer</code> type</a></li>
<li><a href="#sec-3-3">3.3. Floating point types</a></li>
<li><a href="#sec-3-4">3.4. The <code>character</code> type</a></li>
<li><a href="#sec-3-5">3.5. Casting</a></li>
<li><a href="#sec-3-6">3.6. The <code>parameter</code> keyword</a></li>
<li><a href="#sec-3-7">3.7. Setting the precision</a></li>
<li><a href="#sec-3-8">3.8. Pointers</a></li>
<li><a href="#sec-3-9">3.9. Arrays</a>
<ul>
<li><a href="#sec-3-9-1">3.9.1. Fixed-length arrays</a></li>
<li><a href="#sec-3-9-2">3.9.2. Dynamic length arrays</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Control structures</a>
<ul>
<li><a href="#sec-4-1">4.1. Conditionals</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1. The <code>if</code> construct</a></li>
<li><a href="#sec-4-1-2">4.1.2. Example: <code>if</code> / <code>else</code> and random number generation</a></li>
<li><a href="#sec-4-1-3">4.1.3. Example: <code>if</code> / <code>else if</code> / <code>else</code></a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. Loops</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1. The <code>do</code> loop</a>
<ul>
<li><a href="#sec-4-2-1-1">4.2.1.1. Example: row-major matrix</a></li>
</ul>
</li>
<li><a href="#sec-4-2-2">4.2.2. The <code>do while</code> loop</a>
<ul>
<li><a href="#sec-4-2-2-1">4.2.2.1. Example: truncated sum</a></li>
<li><a href="#sec-4-2-2-2">4.2.2.2. Example: estimating machine epsilon</a></li>
</ul>
</li>
<li><a href="#sec-4-2-3">4.2.3. Example: the <code>exit</code> keyword</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. Input/Output</a>
<ul>
<li><a href="#sec-5-1">5.1. File input/output</a>
<ul>
<li><a href="#sec-5-1-1">5.1.1. Reading data from file</a></li>
<li><a href="#sec-5-1-2">5.1.2. Writing data to file</a></li>
</ul>
</li>
<li><a href="#sec-5-2">5.2. Formatted input/output</a></li>
<li><a href="#sec-5-3">5.3. Command line arguments</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Functions/Subroutines</a>
<ul>
<li><a href="#sec-6-1">6.1. Writing a function</a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. Example: <code>linspace</code>: generating a set of equally-space points</a></li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. Writing a subroutine</a>
<ul>
<li><a href="#sec-6-2-1">6.2.1. Example: polar coordinates</a></li>
</ul>
</li>
<li><a href="#sec-6-3">6.3. Passing procedures as arguments</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1. Example: Newton's method for rootfinding</a></li>
<li><a href="#sec-6-3-2">6.3.2. Example: The midpoint rule for definite integrals</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4. Polymorphism</a>
<ul>
<li><a href="#sec-6-4-1">6.4.1. Example: machine epsilon</a></li>
</ul>
</li>
<li><a href="#sec-6-5">6.5. Recursion</a>
<ul>
<li><a href="#sec-6-5-1">6.5.1. Example: factorial</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. Object-oriented programming</a>
<ul>
<li><a href="#sec-7-1">7.1. Derived types</a></li>
<li><a href="#sec-7-2">7.2. Modules</a></li>
<li><a href="#sec-7-3">7.3. Example: determinant of random matrix</a></li>
<li><a href="#sec-7-4">7.4. Example: matrix module</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="footer"><a href="../../../">ACM Computing Seminar Home</a> &mdash; This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.</div>
<a href="javascript:;" id="toc-open">&#9776;</a>
<a href="javascript:;" id="toc-close">&times;</a>


<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This guide is intended to quickly get you up-and-running in scientific computing with Fortran. 
</p>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> About the language</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Fortran was created in the 1950s for mathematical <b>FOR</b>-mula <b>TRAN</b>-slation, and has since gone through a number of revisions (FORTRAN 66, 77, and Fortran 90, 95, 2003, 2008, 2015). The language standards are put forth by the Fortran standards committee <a href="http://www.j3-fortran.org">J3</a> in a document (ISO 1539-1:2010) available for purchase. The language syntax and intrinsic procedures make it especially suited for scientific computing. Fortran is a <b>statically-typed</b> and <b>compiled</b> language, like C++. You must declare the <b>type</b>, i.e. integer, real number, etc. of variables in programs you write. Your programs will be translated from human-readable <i>source code</i> into an executable file by software called a <b>compiler</b>. Fortran is <b>not case-sensitive</b>, so <code>matrix</code> and <code>MaTrIx</code> are translated to the same token by the compiler.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Getting started</h2>
<div class="outline-text-2" id="text-2">
<p>
The software that you need to get started comes prepackaged and ready to download on most Linux distributions. There are a few options for emulating a Linux environment in Windows or Mac OS, such as a virtual machine (VirtualBox) or package manager (MinGW or Cygwin on Windows and Brew on Mac OS).
</p>
</div>
<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Text editor</h3>
<div class="outline-text-3" id="text-2-1">
<p>
You will write the source code of your programs using a text editor. There are many options that have features designed for programming such as syntax highlighting and auto-completion. If you are an impossible-to-please perfectionist, you might want to check out <a href="https://www.gnu.org/s/emacs/">Emacs</a>. If you are easier to please, you might want to check out <a href="https://www.sublimetext.com/">Sublime Text</a>.
</p>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Compiler</h3>
<div class="outline-text-3" id="text-2-2">
<p>
To translate your source code into an executable, you will need a Fortran compiler. A free option is <b>gfortran</b>, part of the GNU compiler collection (gcc). The features of the Fortran language that are supported by the <code>gfortran</code> compiler are specified in the <a href="https://gcc.gnu.org/onlinedocs/gfortran/">compiler manual</a>. This is your most complete reference for the procedures intrinsic to Fortran that your programs can use. At the time of this writing, <code>gfortran</code> completely supports Fortran 95 and partially supports more recent standards.
</p>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Writing and compiling a program</h3>
<div class="outline-text-3" id="text-2-3">
<p>
A program is delimited by the <code>begin program</code> / <code>end program</code> keywords. A useful construct for keeping code that a program can use is called a <b>module</b>. A module is delimited by the <code>begin module</code> / <code>end module</code> keywords.
</p>
</div>
<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1"><span class="section-number-4">2.3.1</span> Hello world</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
Let's write a tiny program that prints "hello world" to the terminal screen in <code>hello.f90</code>.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>program main
<span class="linenr">2: </span>  print*, 'hello world'
<span class="linenr">3: </span>end program main
</pre>
</div>

<p>
To compile the program, execute the following command on the command line in the same directory as <code>hello.f90</code>
</p>

<div class="org-src-container">

<pre class="src src-sh">gfortran hello.f90
</pre>
</div>

<p>
This produces an executable file named <code>a.out</code> by default (On Windows, this is probably named <code>a.exe</code> by default). To run, execute the file.
</p>

<div class="org-src-container">

<pre class="src src-sh">./a.out
</pre>
</div>

<p>
We could have specified a different name for the executable file during compilation with the <code>-o</code> option of <code>gfortran</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">gfortran hello.f90 -o my_executable_file
</pre>
</div>

<p>
On Windows, you should append the <code>.exe</code> extension to <code>my_executable_file</code>.
</p>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2"><span class="section-number-4">2.3.2</span> Template</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
Now let's write an empty source code template for future projects. Our source code template will consist of two files in the same directory (<a href="./source/">./source/</a>). In the following files, the contents of a line after a <code>!</code> symbol is a comment that is ignored by the compiler. One file <code>header.f90</code> contains a module that defines things to be used in the main program.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>module header
<span id="coderef-in1" class="coderef-off"><span class="linenr">2: </span>  implicit none</span>
<span class="linenr">3: </span>  ! variable declarations and assignments
<span class="linenr">4: </span>contains
<span class="linenr">5: </span>  ! function and subroutine definitions
<span class="linenr">6: </span>end module header
</pre>
</div>

<p>
This file should be compiled with the <code>-c</code> option of <code>gfortran</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">gfortran -c header.f90
</pre>
</div>

<p>
This outputs the <b>object file</b> named <code>header.o</code> by default. An object file contains machine code that can be <i>linked</i> to an executable. A separate file <code>main.f90</code> contains the main program.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>program main
<span id="coderef-u" class="coderef-off"><span class="linenr">2: </span>  use header</span>
<span id="coderef-in2" class="coderef-off"><span class="linenr">3: </span>  implicit none</span>
<span class="linenr">4: </span>  ! variable declarations and assignments
<span class="linenr">5: </span>  ! function and subroutine calls
<span class="linenr">6: </span>contains
<span class="linenr">7: </span>  ! function and subroutine definitions
<span class="linenr">8: </span>end program main
</pre>
</div>

<p>
On line <a href="#coderef-u"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-u');" onmouseout="CodeHighlightOff(this, 'coderef-u');">2</a> of <code>main.f90</code>, we instruct the main program to use the contents of <code>header.f90</code>, so we must link <code>header.o</code> when compiling <code>main.f90</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">gfortran main.f90 header.o -o main
</pre>
</div>

<p>
To run the program, execute the output file <code>main</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh">./main
</pre>
</div>

<p>
As you get more experience, you may find it cumbersome to repeatedly execute <code>gfortran</code> commands with every modification to your code. A way around this is to use the <code>make</code> command-line utility. Using <code>make</code>, all the of the compilation commands for your project can be coded in a file named <code>makefile</code> in the same directory as your <code>.f90</code> source files. For example, the template above could use the following <code>makefile</code>.
</p>

<div class="org-src-container">

<pre class="src src-make"><span class="linenr"> 1: </span>COMPILER = gfortran
<span class="linenr"> 2: </span>SOURCE = main.f90
<span class="linenr"> 3: </span>EXECUTABLE = main
<span id="coderef-obj" class="coderef-off"><span class="linenr"> 4: </span>OBJECTS = header.o</span>
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>all: $(EXECUTABLE)
<span class="linenr"> 7: </span>$(EXECUTABLE): $(OBJECTS)
<span class="linenr"> 8: </span>	$(COMPILER) $(SOURCE) $(OBJECTS) -o $(EXECUTABLE)
<span class="linenr"> 9: </span>%.o: %.f90
<span class="linenr">10: </span>	$(COMPILER) -c $&lt;
</pre>
</div>

<p>
Then, to recompile both <code>header.f90</code> and <code>main.f90</code> after modifying either file, execute
</p>

<div class="org-src-container">

<pre class="src src-sh">make
</pre>
</div>

<p>
in the same directory as <code>makefile</code>. The first four lines of the <code>makefile</code> above define the compiler command, file name of the main program, file name of the executable to be created, and file name(s) of linked object file(s), respectively. If you wrote a second module in a separate file <code>my_second_header.f90</code> that you wanted to <code>use</code> in <code>main.f90</code>, you would modify line <a href="#coderef-obj"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-obj');" onmouseout="CodeHighlightOff(this, 'coderef-obj');">4</a> of <code>makefile</code> to <code>OBJ = header.o my_second_header.o</code>. The remaining lines of <code>makefile</code> define instructions for compilation.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4"><span class="section-number-3">2.4</span> Exercises</h3>
<div class="outline-text-3" id="text-2-4">
<ol class="org-ol">
<li>Compile and run <code>hello.f90</code>.
</li>
<li>Execute <code>man gfortran</code> in any directory to bring up the manual for <code>gfortran</code>. Read the description and skim through the options. Do the same for <code>make</code>.
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Data types</h2>
<div class="outline-text-2" id="text-3">
<p>
In both programs and modules, variables are declared first before other procedures. A variable is declared by listing its data type followed by <code>::</code> and the variable name, i.e. <code>integer :: i</code> or <code>real :: x</code>.
</p>

<p>
We will use the <code>implicit none</code> keyword at the beginning of each program and module as in line <a href="#coderef-in1"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-in1');" onmouseout="CodeHighlightOff(this, 'coderef-in1');">2</a> of <code>header.f90</code> and line <a href="#coderef-in2"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-in2');" onmouseout="CodeHighlightOff(this, 'coderef-in2');">3</a> of <code>main.f90</code> in Section <a href="#sec-2-3-2">2.3.2</a>. The role of this keyword is to suppress implicit rules for interpreting undeclared variables. By including it, we force ourselves to declare each variable we use, which should facilitate debugging when our program fails to compile. Without it, an undeclared variable with a name such as <code>i</code> is assumed to be of the <code>integer</code> data type whereas an undeclared variable with a name such as <code>x</code> is assumed to be of the <code>real</code> data type.
</p>

<p>
In addition to the most common data types presented below, Fortran has a <code>complex</code> data type and support for data types defined by the programmer (see Section <a href="#sec-7-1">7.1</a>).
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> The <code>logical</code> type</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A <code>logical</code> data type can have values <code>.true.</code> or <code>.false.</code>. Logical expressions can be expressed by combining unary or binary operations.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>logical :: a,b,c
<span class="linenr"> 2: </span>a = .true.
<span class="linenr"> 3: </span>b = .false.
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>! '.not.' is the logical negation operator
<span class="linenr"> 6: </span>c = .not.a ! c is false
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>! '.and,' is the logical and operator
<span class="linenr"> 9: </span>c = a.and.b ! c is false
<span class="linenr">10: </span>
<span class="linenr">11: </span>! '.or.' is the logical or operator
<span class="linenr">12: </span>c = a.or.b ! c is true
<span class="linenr">13: </span>
<span class="linenr">14: </span>! '==' is the test for equality
<span class="linenr">15: </span>c = 1 == 2 ! c is false
<span class="linenr">16: </span>
<span class="linenr">17: </span>! '/=' is test for inequality
<span class="linenr">18: </span>c = 1 /= 2 ! c is true
<span class="linenr">19: </span>print*, c
</pre>
</div>

<p>
Other logical operators include
</p>
<ul class="org-ul">
<li><code>&lt;</code> or <code>.lt.</code>: less than
</li>
<li><code>&lt;=</code> or <code>.le.</code>: less than or equal
</li>
<li><code>&gt;</code> or <code>.gt.</code>: greater than
</li>
<li><code>&gt;=</code> or <code>.ge.</code>: greater than or equal
</li>
</ul>

<p>
Logical expressions are often used in <a href="#sec-4">control structures</a>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> The <code>integer</code> type</h3>
<div class="outline-text-3" id="text-3-2">
<p>
An <code>integer</code> data type can have integer values. If a real value is assigned to an <code>integer</code> type, the decimal portion is chopped off.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>integer :: a = 6, b = 7 ! initialize a and b to 6 and 7, resp
<span class="linenr"> 2: </span>integer :: c
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>c = a + b ! c is 13
<span class="linenr"> 5: </span>c = a - b ! c is -1
<span class="linenr"> 6: </span>c = a / b ! c is 0
<span class="linenr"> 7: </span>c = b / a ! c is 1
<span class="linenr"> 8: </span>c = a*b ! c is 42
<span class="linenr"> 9: </span>c = a**b ! c is 6^7
<span class="linenr">10: </span>c = mod(b,a) ! c is (b mod a) = 1
<span class="linenr">11: </span>c = a &gt; b ! c is 0 (logical gets cast to integer)
<span class="linenr">12: </span>c = a &lt; b ! c is 1 (logical gets cast to integer)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Floating point types</h3>
<div class="outline-text-3" id="text-3-3">
<p>
The two floating point data types <code>real</code> and <code>double precision</code> correspond to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 32- and 64-bit floating point data types</a>. A constant called <i>machine epsilon</i> is the least positive number in a floating point system that when added to 1 results in a floating point number larger than 1. It is common in numerical analysis error estimates.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>real :: a ! declare a single precision float
<span class="linenr"> 2: </span>double precision :: b ! declare a double precision float
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>! Print the min/max value and machine epsilon
<span class="linenr"> 5: </span>! for the single precision floating point system
<span class="linenr"> 6: </span>print*, tiny(a), huge(a), epsilon(a)
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>! Print the min/max value and machine epsilon
<span class="linenr"> 9: </span>! for the double precision floating point system
<span class="linenr">10: </span>print*, tiny(b), huge(b), epsilon(b)
</pre>
</div>

<pre class="example">
1.17549435E-38   3.40282347E+38   1.19209290E-07
2.2250738585072014E-308   1.7976931348623157E+308   2.2204460492503131E-016
</pre>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> The <code>character</code> type</h3>
<div class="outline-text-3" id="text-3-4">
<p>
A <code>character</code> data type can have character values, i.e. letters or symbols. A character string is declared with a positive <code>integer</code> specifying its maximum possible length.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>! declare a character variable s at most 32 characters
<span class="linenr">2: </span>character(32) :: s
<span class="linenr">3: </span>
<span class="linenr">4: </span>! assign value to s
<span class="linenr">5: </span>s = 'file_name'
<span class="linenr">6: </span>
<span class="linenr">7: </span>! trim trailing spaces from s and
<span class="linenr">8: </span>! append a character literal '.txt'
<span class="linenr">9: </span>print*, trim(s) // '.txt'
</pre>
</div>

<pre class="example">
file_name.txt
</pre>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Casting</h3>
<div class="outline-text-3" id="text-3-5">
<p>
An <code>integer</code> can be cast to a <code>real</code> and vice versa.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>integer :: a = 1, b
<span class="linenr"> 2: </span>real :: c, PI = 3.14159
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>! explicit cast real to integer
<span class="linenr"> 5: </span>b = int(PI) ! b is 3
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>! explicit cast integer to real then divide
<span class="linenr"> 8: </span>c = a/real(b) ! c is .3333...
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>! divide then implicit cast real to integer
<span class="linenr">11: </span>c = a/b ! c is 0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> The <code>parameter</code> keyword</h3>
<div class="outline-text-3" id="text-3-6">
<p>
The <code>parameter</code> keyword is used to declare constants. A constant must be assigned a value at declaration and cannot be reassigned a value. The following code is not valid because of an attempt to reassign a constant.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>! declare constant variable
<span class="linenr">2: </span>real, parameter :: PI = 2.*asin(1.) ! 'asin' is arcsine
<span class="linenr">3: </span>
<span class="linenr">4: </span>PI = 3 ! not valid
</pre>
</div>

<p>
The compiler produces an error like <code>Error: Named constant ‘pi’ in variable definition context (assignment)</code>.
</p>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Setting the precision</h3>
<div class="outline-text-3" id="text-3-7">
<p>
The <code>kind</code> function returns an <code>integer</code> for each data type. The precision of a floating point number can be specified at declaration by a literal or constant <code>integer</code> of the desired <code>kind</code>.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare a single precision
<span class="linenr"> 2: </span>real :: r 
<span class="linenr"> 3: </span>! declare a double precision
<span class="linenr"> 4: </span>double precision :: d
<span class="linenr"> 5: </span>! store single precision and double precision kinds
<span class="linenr"> 6: </span>integer, parameter :: sp = kind(r), dp = kind(d)
<span class="linenr"> 7: </span>! set current kind
<span id="coderef-rp" class="coderef-off"><span class="linenr"> 8: </span>integer, parameter :: rp = sp</span>
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>! declare real b in double precision
<span class="linenr">11: </span>real(dp) :: b
<span class="linenr">12: </span>
<span class="linenr">13: </span>! declare real a with precision kind rp
<span class="linenr">14: </span>real(rp) :: a
<span class="linenr">15: </span>
<span class="linenr">16: </span>! cast 1 to real with precision kind rp and assign to a
<span class="linenr">17: </span>a = 1.0_rp
<span class="linenr">18: </span>
<span class="linenr">19: </span>! cast b to real with precision kind rp and assign to a
<span class="linenr">20: </span>a = real(b,rp)
</pre>
</div>

<p>
To switch the precision of each variable above with kind <code>rp</code>, we would only need to modify the declaration of <code>rp</code> on line <a href="#coderef-rp"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-rp');" onmouseout="CodeHighlightOff(this, 'coderef-rp');">8</a>.
</p>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Pointers</h3>
<div class="outline-text-3" id="text-3-8">
<p>
Pointers have the same meaning in Fortran as in C++. A pointer is a variable that holds the <b>memory address</b> of a variable. The implementation of pointers is qualitatively different in Fortran than in C++. In Fortran, the user cannot view the memory address that a pointer stores. A pointer variable is declared with the <code>pointer</code> modifier, and a variable that it points to is declared with the <code>target</code> modifier. The types of a <code>pointer</code> and its <code>target</code> must match.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare pointer
<span class="linenr"> 2: </span>integer, pointer :: p
<span class="linenr"> 3: </span>! declare targets
<span class="linenr"> 4: </span>integer, target :: a = 1, b = 2
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>p =&gt; a ! p has same memory address as a
<span class="linenr"> 7: </span>p = 2 ! modify value at address
<span class="linenr"> 8: </span>print*, a==2 ! a is 2
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>p =&gt; b ! p has same memory address as b
<span class="linenr">11: </span>p = 1 ! modify value at address
<span class="linenr">12: </span>print*, b==1 ! b is 1
<span class="linenr">13: </span>
<span class="linenr">14: </span>! is p associated with a target?
<span class="linenr">15: </span>print*, associated(p)
<span class="linenr">16: </span>
<span class="linenr">17: </span>! is p associated with the target a?
<span class="linenr">18: </span>print*, associated(p, a)
<span class="linenr">19: </span>
<span class="linenr">20: </span>! point to nowhere
<span class="linenr">21: </span>nullify(p)
</pre>
</div>

<pre class="example">
T
T
T
F
</pre>
</div>
</div>

<div id="outline-container-sec-3-9" class="outline-3">
<h3 id="sec-3-9"><span class="section-number-3">3.9</span> Arrays</h3>
<div class="outline-text-3" id="text-3-9">
<p>
The length of an array can be fixed or dynamic. The index of an array starts at 1 by default, but any index range can be specified.
</p>
</div>
<div id="outline-container-sec-3-9-1" class="outline-4">
<h4 id="sec-3-9-1"><span class="section-number-4">3.9.1</span> Fixed-length arrays</h4>
<div class="outline-text-4" id="text-3-9-1">
<p>
An array can be declared with a single <code>integer</code> specifying its length in which cast the first index of the array is 1. An array can also be declared with an <code>integer</code> range specifying its first and last index.
</p>

<p>
Here's a one-dimensional array example.
</p>
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare arrray of length 5
<span class="linenr"> 2: </span>! index range is 1 to 5 (inclusive)
<span class="linenr"> 3: </span>real :: a(5)
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>! you can work with each component individually
<span class="linenr"> 6: </span>! set the first component to 1
<span class="linenr"> 7: </span>a(1) = 1.0
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>! or you can work with the whole array
<span class="linenr">10: </span>! set the whole array to 2
<span class="linenr">11: </span>a = 2.0
<span class="linenr">12: </span>
<span class="linenr">13: </span>! or you can with slices of the array
<span class="linenr">14: </span>! set elements 2 to 4 (inclusive) to 3
<span class="linenr">15: </span>a(2:4) = 3.0
</pre>
</div>

<p>
And, here's a two-dimensional array example.
</p>
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare 5x5 array
<span class="linenr"> 2: </span>! index range is 1 to 5 (inclusive) in both axes
<span class="linenr"> 3: </span>real :: a(5,5)
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>! you can work with each component individually
<span class="linenr"> 6: </span>! set upper left component to 1
<span class="linenr"> 7: </span>a(1,1) = 1.0
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>! or you can work with the whole array
<span class="linenr">10: </span>! set the whole array to 2
<span class="linenr">11: </span>a = 2.0
<span class="linenr">12: </span>
<span class="linenr">13: </span>! or you can with slices of the array
<span class="linenr">14: </span>! set a submatrix to 3
<span class="linenr">15: </span>a(2:4, 1:2) = 3.0
</pre>
</div>

<p>
Fortran includes intrinsic functions to operate on an array <code>a</code> such as
</p>
<ul class="org-ul">
<li><code>size(a)</code>: number of elements of <code>a</code>
</li>
<li><code>minval(a)</code>: minimum value of <code>a</code>
</li>
<li><code>maxval(a)</code>: maximum value of <code>a</code>
</li>
<li><code>sum(a)</code>: sum of elements in <code>a</code>
</li>
<li><code>product(a)</code>: product of elements in <code>a</code>
</li>
</ul>
<p>
See the <code>gfortran</code> documentation for more.
</p>
</div>
</div>

<div id="outline-container-sec-3-9-2" class="outline-4">
<h4 id="sec-3-9-2"><span class="section-number-4">3.9.2</span> Dynamic length arrays</h4>
<div class="outline-text-4" id="text-3-9-2">
<p>
Dynamic arrays are declared with the <code>allocatable</code> modifier. Before storing values in such an array, you must <code>allocate</code> memory for the array. After you are finished the array, you ought to <code>deallocate</code> the memory that it occupies.
</p>

<p>
Here's a one-dimensional array example.
</p>
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare a one-dim. dynamic length array
<span class="linenr"> 2: </span>real, allocatable :: a(:)
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>! allocate memory for a
<span class="linenr"> 5: </span>allocate(a(5))
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>! now you can treat a like a normal array
<span class="linenr"> 8: </span>a(1) = 1.0
<span class="linenr"> 9: </span>! etc...
<span class="linenr">10: </span>
<span class="linenr">11: </span>! deallocate memory occupied by a
<span class="linenr">12: </span>deallocate(a)
<span class="linenr">13: </span>
<span class="linenr">14: </span>! we can change the size and index range of a
<span class="linenr">15: </span>allocate(a(0:10))
<span class="linenr">16: </span>
<span class="linenr">17: </span>a(0) = 1.0
<span class="linenr">18: </span>! etc...
<span class="linenr">19: </span>
<span id="coderef-d" class="coderef-off"><span class="linenr">20: </span>deallocate(a)</span>
</pre>
</div>

<p>
Without the last <code>dellaocate</code> statement on line <a href="#coderef-d"class="coderef" onmouseover="CodeHighlightOn(this, 'coderef-d');" onmouseout="CodeHighlightOff(this, 'coderef-d');">20</a> the code above is valid, but the memory that is allocated for <code>a</code> will not be freed. That memory then cannot be allocated to other resources.
</p>

<p>
Here's a two-dimensional array example.
</p>
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare a two-dim. dynamic length array
<span class="linenr"> 2: </span>real, allocatable :: a(:,:)
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>! allocate memory for a
<span class="linenr"> 5: </span>allocate(a(5,5))
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>! now you can treat a like a normal array
<span class="linenr"> 8: </span>a(1,1) = 1.0
<span class="linenr"> 9: </span>! etc...
<span class="linenr">10: </span>
<span class="linenr">11: </span>! deallocate memory occupied by a
<span class="linenr">12: </span>deallocate(a)
<span class="linenr">13: </span>
<span class="linenr">14: </span>! we can change the size and index range of a
<span class="linenr">15: </span>allocate(a(0:10,0:10))
<span class="linenr">16: </span>
<span class="linenr">17: </span>a(0,0) = 1.0
<span class="linenr">18: </span>! etc...
<span class="linenr">19: </span>
<span class="linenr">20: </span>deallocate(a)
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Control structures</h2>
<div class="outline-text-2" id="text-4">
<p>
Control structures are used to direct the flow of code execution.
</p>
</div>
<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Conditionals</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> The <code>if</code> construct</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
The <code>if</code> construct controls execution of a single block of code. If the block of code is more than one line, it should be delimited by an <code>if</code> / <code>end if</code> pair. If the block of code is one line, it can be written on one line. A common typo is to forget the <code>then</code> keyword following the logical in an <code>if</code> / <code>end if</code> pair.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>real :: num = 0.75
<span class="linenr">2: </span>
<span class="linenr">3: </span>if (num &lt; .5) then
<span class="linenr">4: </span>   print*, 'num: ', num
<span class="linenr">5: </span>   print*, 'num is less than 0.5'
<span class="linenr">6: </span>end if
<span class="linenr">7: </span>
<span class="linenr">8: </span>if (num &gt; .5) print*, 'num is greater than 0.5'
</pre>
</div>

<pre class="example">
num is greater than 0.5
</pre>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Example: <code>if</code> / <code>else</code> and random number generation</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
The <code>if</code> / <code>else</code> construct controls with mutually exclusive logic the execution of two blocks of code.
</p>

<p>
The following code generates a random number between 0 and 1, then prints the number and whether or not the number is greater than 0.5
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>real :: num
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>! seed random number generator
<span class="linenr"> 4: </span>call srand(789)
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>! rand() returns a random number between 0 and 1
<span class="linenr"> 7: </span>num = rand()
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>print*, 'num: ', num
<span class="linenr">10: </span>
<span class="linenr">11: </span>if (num &lt; 0.5) then
<span class="linenr">12: </span>   print*, 'num is less than 0.5'
<span class="linenr">13: </span>else
<span class="linenr">14: </span>   print*, 'num is greater then 0.5'
<span class="linenr">15: </span>end if
<span class="linenr">16: </span>
<span class="linenr">17: </span>! do it again
<span class="linenr">18: </span>num = rand()
<span class="linenr">19: </span>
<span class="linenr">20: </span>print*, 'num: ', num
<span class="linenr">21: </span>
<span class="linenr">22: </span>if (num &lt; 0.5) then
<span class="linenr">23: </span>   print*, 'num is less than 0.5'
<span class="linenr">24: </span>else
<span class="linenr">25: </span>   print*, 'num is greater then 0.5'
<span class="linenr">26: </span>end if
</pre>
</div>

<pre class="example">
num:    6.17480278E-03
num is less than 0.5
num:   0.783314705    
num is greater then 0.5
</pre>

<p>
Since the random number generator was seeded with a literal integer, the above code will produce the <i>same</i> output each time it is run.
</p>
</div>
</div>

<div id="outline-container-sec-4-1-3" class="outline-4">
<h4 id="sec-4-1-3"><span class="section-number-4">4.1.3</span> Example: <code>if</code> / <code>else if</code> / <code>else</code></h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
The <code>if</code> / <code>else if</code> / <code>else</code> construct controls with mutually exclusive logic the execution of three or more blocks of code. The following code generates a random number between 0 and 1, then prints the number and which quarter of the interval \([0,1]\) that the number is in.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>real :: num
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>! seed random number generator with current time
<span class="linenr"> 4: </span>call srand(time())
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>! rand() returns a random number between 0 and 1
<span class="linenr"> 7: </span>num = rand()
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>print*, 'num:', num
<span class="linenr">10: </span>
<span class="linenr">11: </span>if (num &gt; 0.75) then
<span class="linenr">12: </span>   print*, 'num is between 0.75 and 1'
<span class="linenr">13: </span>else if (num &gt; 0.5) then
<span class="linenr">14: </span>   print*, 'num is between 0.5 and 0.75'
<span class="linenr">15: </span>else if (num &gt; 0.25) then
<span class="linenr">16: </span>   print*, 'num is between 0.25 and 0.5'
<span class="linenr">17: </span>else
<span class="linenr">18: </span>   print*, 'num is between 0 and 0.25'
<span class="linenr">19: </span>end if
</pre>
</div>

<pre class="example">
num:  0.570252180    
num is between 0.5 and 0.75
</pre>

<p>
Since the random number generator was seeded with the current time, the above code will produce a <i>different</i> output each time it is run.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Loops</h3>
<div class="outline-text-3" id="text-4-2">
</div><div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> The <code>do</code> loop</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
A <code>do</code> loop iterates a block of code over a range of integers. It takes two <code>integer</code> arguments specifying the minimum and maximum (inclusive) of the range and takes an optional third <code>integer</code> argument specifying the iteration stride in the form <code>do i=min,max,stride</code>. If omitted, the stride is 1.
</p>

<p>
The following code assigns a value to each component of an array then prints it.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>integer :: max = 10, i
<span class="linenr"> 2: </span>real, allocatable :: x(:)
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>allocate(x(0:max))
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>do i = 0,max
<span class="linenr"> 7: </span>   ! assign to each array component
<span class="linenr"> 8: </span>   x(i) = i / real(max)
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>   ! print current component
<span class="linenr">11: </span>   print "('x(', i0, ') = ', f3.1)", i, x(i)
<span class="linenr">12: </span>end do
<span class="linenr">13: </span>
<span class="linenr">14: </span>deallocate(x)
</pre>
</div>

<pre class="example">
x(0) = 0.0
x(1) = 0.1
x(2) = 0.2
x(3) = 0.3
x(4) = 0.4
x(5) = 0.5
x(6) = 0.6
x(7) = 0.7
x(8) = 0.8
x(9) = 0.9
x(10) = 1.0
</pre>

<p>
An <i>implicit</i> <code>do loop</code> can be used for formulaic array assignments. The following code creates the same array as the last example.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">1: </span>integer :: max = 10
<span class="linenr">2: </span>real, allocatable :: x(:)
<span class="linenr">3: </span>
<span class="linenr">4: </span>allocate(x(0:max))
<span class="linenr">5: </span>
<span class="linenr">6: </span>! implicit do loop for formulaic array assignment
<span class="linenr">7: </span>x = [(i / real(max), i=0, max)]
<span class="linenr">8: </span>
<span class="linenr">9: </span>deallocate(x)
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-1-1" class="outline-5">
<h5 id="sec-4-2-1-1"><span class="section-number-5">4.2.1.1</span> Example: row-major matrix</h5>
<div class="outline-text-5" id="text-4-2-1-1">
<p>
The following code stores matrix data in a one-dimensional array named <code>matrix</code> in <code>row-major</code> order. This means the first <code>n_cols</code> elements of the array will contain the first row of the matrix, the next <code>n_cols</code> of the array will contain the second row of the matrix, etc.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>integer :: n_rows = 4, n_cols = 3
<span class="linenr"> 2: </span>real, allocatable :: matrix(:)
<span class="linenr"> 3: </span>! temporary indices
<span class="linenr"> 4: </span>integer :: i,j,k
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>! index range is 1 to 12 (inclusive)
<span class="linenr"> 7: </span>allocate(matrix(1:n_rows*n_cols))
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>! assign 0 to all elements of matrix
<span class="linenr">10: </span>matrix = 0.0
<span class="linenr">11: </span>
<span class="linenr">12: </span>do i = 1,n_rows
<span class="linenr">13: </span>   do j = 1,n_cols
<span class="linenr">14: </span>      ! convert (i,j) matrix index to "flat" row-major index
<span class="linenr">15: </span>      k = (i-1)*n_cols + j
<span class="linenr">16: </span>
<span class="linenr">17: </span>      ! assign 1 to diagonal, 2 to sub/super-diagonal
<span class="linenr">18: </span>      if (i==j) then
<span class="linenr">19: </span>	 matrix(k) = 1.0
<span class="linenr">20: </span>      else if ((i==j-1).or.(i==j+1)) then
<span class="linenr">21: </span>	 matrix(k) = 2.0
<span class="linenr">22: </span>      end if
<span class="linenr">23: </span>   end do
<span class="linenr">24: </span>end do
<span class="linenr">25: </span>
<span class="linenr">26: </span>! print matrix row by row
<span class="linenr">27: </span>do i = 1,n_rows
<span class="linenr">28: </span>   print "(3(f5.1))", matrix(1+(i-1)*n_cols:i*n_cols)
<span class="linenr">29: </span>end do
<span class="linenr">30: </span>
<span class="linenr">31: </span>deallocate(matrix)
</pre>
</div>

<pre class="example">
1.0 2.0 0.0
2.0 1.0 2.0
0.0 2.0 1.0
0.0 0.0 2.0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> The <code>do while</code> loop</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
A <code>do while</code> loop iterates while a logical condition evaluates to <code>.true.</code>.
</p>
</div>
<div id="outline-container-sec-4-2-2-1" class="outline-5">
<h5 id="sec-4-2-2-1"><span class="section-number-5">4.2.2.1</span> Example: truncated sum</h5>
<div class="outline-text-5" id="text-4-2-2-1">
<p>
The following code approximates the geometric series
</p>
\begin{equation*}
\sum_{n=1}^{\infty}\left(\frac12\right)^n=1.
\end{equation*}
<p>
The <code>do while</code> loop begins with \(n=1\) and exits when the current summand does not increase the current sum. It prints the iteration number, current sum, and absolute error
</p>
\begin{equation*}
E=1-\sum_{n=1}^{\infty}\left(\frac12\right)^n.
\end{equation*}

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>real :: sum = 0.0, base = 0.5, tol = 1e-4
<span class="linenr"> 2: </span>real :: pow = 0.5
<span class="linenr"> 3: </span>integer :: iter = 1
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>do while (sum+pow &gt; sum)
<span class="linenr"> 6: </span>   ! add pow to sum
<span class="linenr"> 7: </span>   sum = sum+pow
<span class="linenr"> 8: </span>   ! update pow by one power of base
<span class="linenr"> 9: </span>   pow = pow*base
<span class="linenr">10: </span>
<span class="linenr">11: </span>   print "('Iter: ', i3, ', Sum: ', f0.10, ', Abs Err: ', f0.10)", iter, sum, 1-sum
<span class="linenr">12: </span>
<span class="linenr">13: </span>   ! update iter by 1
<span class="linenr">14: </span>   iter = iter+1
<span class="linenr">15: </span>end do
</pre>
</div>

<pre class="example">
Iter:   1, Sum: .5000000000, Abs Err: .5000000000
Iter:   2, Sum: .7500000000, Abs Err: .2500000000
Iter:   3, Sum: .8750000000, Abs Err: .1250000000
Iter:   4, Sum: .9375000000, Abs Err: .0625000000
Iter:   5, Sum: .9687500000, Abs Err: .0312500000
Iter:   6, Sum: .9843750000, Abs Err: .0156250000
Iter:   7, Sum: .9921875000, Abs Err: .0078125000
Iter:   8, Sum: .9960937500, Abs Err: .0039062500
Iter:   9, Sum: .9980468750, Abs Err: .0019531250
Iter:  10, Sum: .9990234375, Abs Err: .0009765625
Iter:  11, Sum: .9995117188, Abs Err: .0004882812
Iter:  12, Sum: .9997558594, Abs Err: .0002441406
Iter:  13, Sum: .9998779297, Abs Err: .0001220703
Iter:  14, Sum: .9999389648, Abs Err: .0000610352
Iter:  15, Sum: .9999694824, Abs Err: .0000305176
Iter:  16, Sum: .9999847412, Abs Err: .0000152588
Iter:  17, Sum: .9999923706, Abs Err: .0000076294
Iter:  18, Sum: .9999961853, Abs Err: .0000038147
Iter:  19, Sum: .9999980927, Abs Err: .0000019073
Iter:  20, Sum: .9999990463, Abs Err: .0000009537
Iter:  21, Sum: .9999995232, Abs Err: .0000004768
Iter:  22, Sum: .9999997616, Abs Err: .0000002384
Iter:  23, Sum: .9999998808, Abs Err: .0000001192
Iter:  24, Sum: .9999999404, Abs Err: .0000000596
Iter:  25, Sum: 1.0000000000, Abs Err: .0000000000
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-2-2" class="outline-5">
<h5 id="sec-4-2-2-2"><span class="section-number-5">4.2.2.2</span> Example: estimating machine epsilon</h5>
<div class="outline-text-5" id="text-4-2-2-2">
<p>
The following code finds machine epsilon by shifting the rightmost bit of a binary number rightward until it falls off. Think about how it does this. Could you write an algorithm that finds machine epsilon using the function <code>rshift</code> that shifts the bits of float rightward?
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>double precision :: eps
<span class="linenr"> 2: </span>integer, parameter :: dp = kind(eps)
<span class="linenr"> 3: </span>integer :: count = 1
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>eps = 1.0_dp
<span class="linenr"> 6: </span>do while (1.0_dp + eps*0.5 &gt; 1.0_dp)
<span class="linenr"> 7: </span>   eps = eps*0.5
<span class="linenr"> 8: </span>   count = count+1
<span class="linenr"> 9: </span>end do
<span class="linenr">10: </span>
<span class="linenr">11: </span>print*, eps, epsilon(eps)
<span class="linenr">12: </span>print*, count, digits(eps)
</pre>
</div>

<pre class="example">
2.2204460492503131E-016   2.2204460492503131E-016
       53          53
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3"><span class="section-number-4">4.2.3</span> Example: the <code>exit</code> keyword</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
The <code>exit</code> keyword stops execution of code within the current scope.
</p>

<p>
The following code finds the <i>hailstone sequence</i> of \(a_1=6\) defined recursively by
</p>
\begin{equation*}
a_{n+1} =
\begin{cases}
a_n/2 & \text{if } a_n \text{ is even}\\
3a_n+1 & \text{ if } a_n \text{ is odd} 
\end{cases}
\end{equation*}
<p>
for \(n\geq1\). It is an open conjecture that the hailstone sequence of any initial value \(a_1\) converges to the periodic sequence \(4, 2, 1, 4, 2, 1\ldots\). Luckily, it does for \(a_1=6\) and the following infinite <code>do</code> loop exits.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>integer :: a = 6, count = 1
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>! infinite loop
<span class="linenr"> 4: </span>do
<span class="linenr"> 5: </span>   ! if a is even, divide by 2
<span class="linenr"> 6: </span>   ! otherwise multiply by 3 and add 1
<span class="linenr"> 7: </span>   if (mod(a,2)==0) then
<span class="linenr"> 8: </span>      a = a/2
<span class="linenr"> 9: </span>   else
<span class="linenr">10: </span>      a = 3*a+1
<span class="linenr">11: </span>   end if
<span class="linenr">12: </span>
<span class="linenr">13: </span>   ! if a is 4, exit infinite loop
<span class="linenr">14: </span>   if (a==4) then
<span class="linenr">15: </span>      exit
<span class="linenr">16: </span>   end if
<span class="linenr">17: </span>
<span class="linenr">18: </span>   ! print count and a
<span class="linenr">19: </span>   print "('count: ', i2, ', a: ', i2)", count, a
<span class="linenr">20: </span>
<span class="linenr">21: </span>   ! increment count
<span class="linenr">22: </span>   count = count + 1
<span class="linenr">23: </span>end do
</pre>
</div>

<pre class="example">
count:  1, a:  3
count:  2, a: 10
count:  3, a:  5
count:  4, a: 16
count:  5, a:  8
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Input/Output</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> File input/output</h3>
<div class="outline-text-3" id="text-5-1">
</div><div id="outline-container-sec-5-1-1" class="outline-4">
<h4 id="sec-5-1-1"><span class="section-number-4">5.1.1</span> Reading data from file</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
The contents of a data file can be read into an array using <code>read</code>. Suppose you have a file <code>./data/array.txt</code> that contains two columns of data
</p>

<pre class="example">
1 1.23
2 2.34
3 3.45
4 4.56
5 5.67
</pre>

<p>
This file can be opened with the <code>open</code> command. The required first argument of <code>open</code> is an <code>integer</code> that specifies a <i>file unit</i> for <code>array.txt</code>. Choose any number that is not in use. The unit numbers <code>0</code>, <code>5</code>, and <code>6</code> are reserved for system files and should not be used accidentally. Data are read in <b>row-major</b> format, i.e. across the first row, then across the second row, etc.
</p>

<p>
The following code reads the contents of <code>./data/array.txt</code> into an array called <code>array</code>.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! declare array
<span class="linenr"> 2: </span>real :: array(5,2)
<span class="linenr"> 3: </span>integer :: row
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>! open file and assign file unit 10
<span class="linenr"> 6: </span>open (10, file='./data/array.txt', action='read')
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>! read data from file unit 10 into array
<span class="linenr"> 9: </span>do row = 1,5
<span class="linenr">10: </span>   read(10,*) array(row,:)
<span class="linenr">11: </span>end do
<span class="linenr">12: </span>
<span class="linenr">13: </span>! close file
<span class="linenr">14: </span>close(10)
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-1-2" class="outline-4">
<h4 id="sec-5-1-2"><span class="section-number-4">5.1.2</span> Writing data to file</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Data can be written to a file with the <code>write</code> command.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>real :: x
<span class="linenr"> 2: </span>integer :: i, max = 5
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>! open file, specify unit 10, overwrite if exists
<span class="linenr"> 5: </span>open(10, file='./data/sine.txt', action='write', status='replace')
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>do i = 0,max
<span class="linenr"> 8: </span>   x = i / real(max)
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>   ! write to file unit 10
<span class="linenr">11: </span>   write(10,*) x, sin(x)
<span class="linenr">12: </span>end do
</pre>
</div>

<p>
This produces a file <code>sine.txt</code> in the directory <code>data</code> containing
</p>

<pre class="example">
 0.00000000       0.00000000    
0.200000003      0.198669329    
0.400000006      0.389418334    
0.600000024      0.564642489    
0.800000012      0.717356086    
 1.00000000      0.841470957    
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Formatted input/output</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The format of a <code>print</code>, <code>write</code>, or <code>read</code> statement can be specified with a <code>character</code> string. A format character string replaces the <code>*</code> symbol in <code>print*</code> and the second <code>*</code> symbol in <code>read(*,*)</code> or <code>write(*,*)</code>. A format string is a list of literal character strings or character descriptors from
</p>
<ul class="org-ul">
<li><code>a</code>: character string
</li>
<li><code>iW</code>: integer
</li>
<li><code>fW.D</code>: float point 
</li>
<li><code>esW.DeE</code>: scientific notation
</li>
<li><code>Wx</code>: space
</li>
</ul>
<p>
where <code>W</code>, <code>D</code>, and <code>E</code> should be replaced by numbers specifying width, number of digits, or number  of exponent digits, resp. The width of a formatted integer or float defaults to the width of the number when <code>W</code> is <code>0</code>.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>character(32) :: fmt, a = 'word' 
<span class="linenr"> 2: </span>integer :: b = 1
<span class="linenr"> 3: </span>real :: c = 2.0, d = 3.0
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>! character string and 4 space-delimited values
<span class="linenr"> 6: </span>print "('four values: ', a, 1x i0, 1x f0.1, 1x, es6.1e1)", trim(a), b, c, d
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>! character string and 2 space-delimited values
<span class="linenr"> 9: </span>fmt = '(a, 2(f0.1, 1x))'
<span class="linenr">10: </span>print fmt, 'two values: ', c, d
</pre>
</div>

<pre class="example">
four values: word 1 2.0 3.0E+0
two values: 2.0 3.0
</pre>
</div>
</div>

<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Command line arguments</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Arguments can be passed to a program from the command line using <code>get_command_argument</code>. The first argument received by <code>get_command_argument</code> is the program executable file name and the remaining arguments are passed by the user. The following program accepts any number of arguments, each at most 32 characters, and prints them.
</p>

<div class="org-src-container">

<pre class="src src-fortran" id="command_line_arguments"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  character(32) :: arg
<span class="linenr"> 5: </span>  integer :: n_arg = 0
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  do
<span class="linenr"> 8: </span>     ! get next command line argument
<span class="linenr"> 9: </span>     call get_command_argument(n_arg, arg)
<span class="linenr">10: </span>
<span class="linenr">11: </span>     ! if it is empty, exit
<span class="linenr">12: </span>     if (len_trim(arg) == 0) exit
<span class="linenr">13: </span>
<span class="linenr">14: </span>     ! print argument to screen
<span class="linenr">15: </span>     print"('argument ', i0, ': ', a)", n_arg, trim(arg)
<span class="linenr">16: </span>
<span class="linenr">17: </span>     ! increment count
<span class="linenr">18: </span>     n_arg = n_arg+1
<span class="linenr">19: </span>  end do
<span class="linenr">20: </span>
<span class="linenr">21: </span>  ! print total number of arguments
<span class="linenr">22: </span>  print "('number of arguments: ', i0)", n_arg
<span class="linenr">23: </span>
<span class="linenr">24: </span>end program main
</pre>
</div>

<p>
After compiling to <code>a.out</code>, you can pass arguments in the executing command.
</p>

<div class="org-src-container">

<pre class="src src-sh">./a.out 1 2 34
</pre>
</div>

<pre class="example">
argument 0: ./a.out
argument 1: 1
argument 2: 2
argument 3: 34
number of arguments: 4
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Functions/Subroutines</h2>
<div class="outline-text-2" id="text-6">
<p>
Functions and subroutines are callable blocks of code. A <code>function</code> returns a value from a set of arguments. A <code>subroutine</code> executes a block of code from a set of arguments but does not explicitly return a value. Changes to arguments made within a <code>function</code> are not returned whereas changes to arguments made within a <code>subroutine</code> can be returned to the calling program. Both functions and subroutines are defined after the <code>contains</code> keyword in a <code>module</code> or <code>program</code>.
</p>
</div>
<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Writing a function</h3>
<div class="outline-text-3" id="text-6-1">
<p>
The definition of a function starts with the name of the function followed by a list of arguments and return variable. The data types of the arguments and return variable are defined within the <code>function</code> body.
</p>
</div>
<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> Example: <code>linspace</code>: generating a set of equally-space points</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
The following program defines a function <code>linspace</code> that returns a set of equidistant points on an interval. The main function makes a call to the function.
</p>
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  real :: xs(10)
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  ! call function linspace to set values in xs
<span class="linenr"> 7: </span>  xs = linspace(0.0, 1.0, 10)
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  ! print returned value of xs
<span class="linenr">10: </span>  print "(10(f0.1, 1x))" , xs
<span class="linenr">11: </span>
<span class="linenr">12: </span>contains
<span class="linenr">13: </span>
<span class="linenr">14: </span>  ! linspace: return a set of equidistant points on an interval
<span class="linenr">15: </span>  ! min: minimum value of interval
<span class="linenr">16: </span>  ! max: maximum value of interval
<span class="linenr">17: </span>  ! n_points: number of points in returned set
<span class="linenr">18: </span>  ! xs: set of points
<span class="linenr">19: </span>  function linspace(min, max, n_points) result(xs)
<span class="linenr">20: </span>    real :: min, max, dx
<span class="linenr">21: </span>    integer :: n_points
<span class="linenr">22: </span>    integer :: i
<span class="linenr">23: </span>    real :: xs(n_points)
<span class="linenr">24: </span>
<span class="linenr">25: </span>    ! calculate width of subintervals
<span class="linenr">26: </span>    dx = (max-min) / real(n_points-1)
<span class="linenr">27: </span>
<span class="linenr">28: </span>    ! fill xs with points
<span class="linenr">29: </span>    do i = 1,n_points
<span class="linenr">30: </span>       xs(i) = min + (i-1)*dx
<span class="linenr">31: </span>    end do
<span class="linenr">32: </span>
<span class="linenr">33: </span>  end function linspace
<span class="linenr">34: </span>
<span class="linenr">35: </span>end program main
</pre>
</div>

<pre class="example">
.0 .1 .2 .3 .4 .6 .7 .8 .9 1.0
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Writing a subroutine</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The definition of a subroutine begins with the name of the subroutine and list of arguments. Arguments are defined within the <code>subroutine</code> body with one of the following intents
</p>
<ul class="org-ul">
<li><code>intent(in)</code>: changes to the argument are not returned
</li>
<li><code>intent(inout)</code>: changes to the argument are returned
</li>
<li><code>intent(out)</code>: the initial value of the argument is ignored and changes to the argument are returned.
</li>
</ul>
<p>
Subroutines are called using the <code>call</code> keyword followed by the subroutine name.
</p>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> Example: polar coordinates</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
The following code defines a subroutine <code>polar_coord</code> that returns the polar coordinates \((r,\theta)\) defined by \(r=\sqrt{x^2+y^2}\) and \(\theta=\arctan(y/x)\) from the rectangular coordinate pair \((x,y)\).
</p>
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>  real :: x = 1.0, y = 1.0, rad, theta
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  ! call subroutine that returns polar coords
<span class="linenr"> 6: </span>  call polar_coord(x, y, rad, theta)
<span class="linenr"> 7: </span>  print*, rad, theta
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>contains
<span class="linenr">10: </span>
<span class="linenr">11: </span>  ! polar_coord: return the polar coordinates of a rect coord pair
<span class="linenr">12: </span>  ! x,y: rectangular coord
<span class="linenr">13: </span>  ! rad,theta: polar coord
<span class="linenr">14: </span>  subroutine polar_coord(x, y, rad, theta)
<span class="linenr">15: </span>    real, intent(in) :: x, y
<span class="linenr">16: </span>    real, intent(out) :: rad, theta
<span class="linenr">17: </span>
<span class="linenr">18: </span>    ! compute polar coord
<span class="linenr">19: </span>    ! hypot = sqrt(x**2+y**2) is an intrinsic function
<span class="linenr">20: </span>    ! atan2 = arctan with correct sign is an intrinsic function
<span class="linenr">21: </span>    rad = hypot(x, y)
<span class="linenr">22: </span>    theta = atan2(y, x)
<span class="linenr">23: </span>
<span class="linenr">24: </span>    end subroutine polar_coord
<span class="linenr">25: </span>
<span class="linenr">26: </span>end program main
</pre>
</div>

<pre class="example">
1.41421354      0.785398185
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Passing procedures as arguments</h3>
<div class="outline-text-3" id="text-6-3">
<p>
An <code>inteface</code> can be used to pass a function or subroutine to another function or a subroutine. For this purpose, an <code>interface</code> is defined in the receiving procedure essentially the same way as the passed procedure itself but with only declarations and not the implementation.
</p>
</div>
<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> Example: Newton's method for rootfinding</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
Newton's method for finding the root of a function \(f:\mathbb{R}\rightarrow\mathbb{R}\) refines an initial guess \(x_0\) according to the iteration rule
</p>
\begin{equation*}
x_{n+1}=x_n-\frac{f(x_n)}{f'(x_n)}
\end{equation*}
<p>
for \(n\geq1\) until \(f(x)\) is less than a chosen tolerance or a maximum number of iterations.
</p>

<p>
The following code defines a subroutine <code>newton_root</code> that returns a root of an input function as well as the number of iterations of Newton's method used to find the root. It is called by the  main program to approximate the positive root of \(f(x)=x^2-2\) from an initial guess \(x_0=1\).
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  character(64) :: fmt
<span class="linenr"> 5: </span>  real :: x = 1.0
<span class="linenr"> 6: </span>  integer :: iter = 1000
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  ! call newton rootfinding function
<span class="linenr"> 9: </span>  call newton_root(f, df, x, iter, 1e-6, .true.)
<span class="linenr">10: </span>
<span class="linenr">11: </span>  ! print found root and number of iterations used
<span class="linenr">12: </span>  fmt = "('number of iterations: ', i0, ', x: ', f0.7, ', f(x): ', f0.7)"
<span class="linenr">13: </span>  print fmt, iter, x, f(x)
<span class="linenr">14: </span>
<span class="linenr">15: </span>contains
<span class="linenr">16: </span>
<span class="linenr">17: </span>  ! function f(x) = x^2 - 2
<span class="linenr">18: </span>  function f(x) result(y)
<span class="linenr">19: </span>    real :: x, y
<span class="linenr">20: </span>    y = x*x - 2
<span class="linenr">21: </span>  end function f
<span class="linenr">22: </span>
<span class="linenr">23: </span>  ! function df(x) = 2x
<span class="linenr">24: </span>  function df(x) result(dy)
<span class="linenr">25: </span>    real :: x, dy
<span class="linenr">26: </span>    dy = 2*x
<span class="linenr">27: </span>  end function df
<span class="linenr">28: </span>
<span class="linenr">29: </span>  ! newton_root: newtons method for rootfinding
<span class="linenr">30: </span>  ! f: function with root
<span class="linenr">31: </span>  ! df: derivative of f
<span class="linenr">32: </span>  ! x: sequence iterate
<span class="linenr">33: </span>  ! iter: max number of iterations at call, number of iterations at return
<span class="linenr">34: </span>  ! tol: absolute tolerance
<span class="linenr">35: </span>  ! print_iters: boolean to toggle verbosity
<span class="linenr">36: </span>  subroutine newton_root(f, df, x, iter, tol, print_iters)
<span class="linenr">37: </span>
<span class="linenr">38: </span>    ! interface to function f
<span class="linenr">39: </span>    interface
<span class="linenr">40: </span>       function f(x) result(y)
<span class="linenr">41: </span>	 real :: x, y
<span class="linenr">42: </span>       end function f
<span class="linenr">43: </span>    end interface
<span class="linenr">44: </span>
<span class="linenr">45: </span>    ! interface to function df
<span class="linenr">46: </span>    interface
<span class="linenr">47: </span>       function df(x) result(dy)
<span class="linenr">48: </span>	 real :: x, dy
<span class="linenr">49: </span>       end function df
<span class="linenr">50: </span>    end interface
<span class="linenr">51: </span>
<span class="linenr">52: </span>    real, intent(inout) :: x
<span class="linenr">53: </span>    real, intent(in) :: tol
<span class="linenr">54: </span>    integer, intent(inout) :: iter
<span class="linenr">55: </span>    logical, intent(in) :: print_iters
<span class="linenr">56: </span>    integer :: max_iters
<span class="linenr">57: </span>
<span class="linenr">58: </span>    max_iters = iter
<span class="linenr">59: </span>    iter = 0
<span class="linenr">60: </span>
<span class="linenr">61: </span>    ! while f(x) greater than absolute tolerance
<span class="linenr">62: </span>    ! and max number of iterations not exceeded
<span class="linenr">63: </span>    do while (abs(f(x))&gt;tol.and.iter&lt;max_iters)
<span class="linenr">64: </span>       ! print current x and f(x)
<span class="linenr">65: </span>       if (print_iters) print "('f(', f0.7, ') = ', f0.7)", x, f(x)
<span class="linenr">66: </span>
<span class="linenr">67: </span>       ! Newton's update rule
<span class="linenr">68: </span>       x = x - f(x)/df(x)
<span class="linenr">69: </span>
<span class="linenr">70: </span>       ! increment number of iterations
<span class="linenr">71: </span>       iter = iter + 1
<span class="linenr">72: </span>    end do
<span class="linenr">73: </span>
<span class="linenr">74: </span>  end subroutine newton_root
<span class="linenr">75: </span>
<span class="linenr">76: </span>end program main
</pre>
</div>

<pre class="example">
f(1.0000000) = -1.0000000
f(1.5000000) = .2500000
f(1.4166666) = .0069444
f(1.4142157) = .0000060
number of iterations: 4, x: 1.4142135, f(x): -.0000001
</pre>
</div>
</div>

<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2"><span class="section-number-4">6.3.2</span> Example: The midpoint rule for definite integrals</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
The midpoint rule approximates the definite integral \(\int_a^bf(x)~dx\) with integrand \(f:\mathbb{R}\rightarrow\mathbb{R}\) by
</p>
\begin{equation}
\Delta x\sum_{i=1}^nf(\bar{x}_i)
\end{equation}
<p>
where \(\Delta x=(b-a)/n\), \(x_i=a+i\Delta x\) and \(\bar{x}_i=(x_{i-1}+x_i)/2\).
</p>

<p>
The following code defines a function <code>midpoint</code> that computes the approximation eq. <a href="#eq:midpoint">1</a> given \(a\), \(b\), and \(n\). The main program calls <code>midpoint</code> to approximate the definite integral of \(f(x)=1/x\) on \([1,e]\) for a range of \(n\).
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  real, parameter :: E = exp(1.)
<span class="linenr"> 5: </span>  integer :: n
<span class="linenr"> 6: </span>  real :: integral
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  ! Approximate the integral of 1/x from 1 to e
<span class="linenr"> 9: </span>  ! with the midpoint rule for a range of number of subintervals
<span class="linenr">10: </span>  do n = 2,20,2
<span class="linenr">11: </span>     print "('n: ', i0, ', M_n: ', f0.6)", n, midpoint(f, 1.0, E, n)
<span class="linenr">12: </span>  end do
<span class="linenr">13: </span>
<span class="linenr">14: </span>contains
<span class="linenr">15: </span>
<span class="linenr">16: </span>  ! function f(x) = 1/x
<span class="linenr">17: </span>  function f(x) result(y)
<span class="linenr">18: </span>    real :: x, y
<span class="linenr">19: </span>    y = 1.0/x
<span class="linenr">20: </span>  end function f
<span class="linenr">21: </span>
<span class="linenr">22: </span>  ! midpoint: midpoint rule for definite integral
<span class="linenr">23: </span>  ! f: integrand
<span class="linenr">24: </span>  ! a: left endpoint of interval of integration
<span class="linenr">25: </span>  ! b: right endpoint of interval of integration
<span class="linenr">26: </span>  ! n: number of subintervals
<span class="linenr">27: </span>  ! sum: approximate definite integral
<span class="linenr">28: </span>  function midpoint(f, a, b, n) result(sum)
<span class="linenr">29: </span>
<span class="linenr">30: </span>    ! interface to f
<span class="linenr">31: </span>    interface
<span class="linenr">32: </span>       function f(x)
<span class="linenr">33: </span>	 real :: x, y
<span class="linenr">34: </span>       end function f
<span class="linenr">35: </span>    end interface
<span class="linenr">36: </span>
<span class="linenr">37: </span>    real :: a, b, min, xi, dx, sum
<span class="linenr">38: </span>    integer :: n, i
<span class="linenr">39: </span>
<span class="linenr">40: </span>    ! subinterval increment
<span class="linenr">41: </span>    dx = (b-a)/real(n)
<span class="linenr">42: </span>    ! minimum to increment from
<span class="linenr">43: </span>    min = a - dx/2.0
<span class="linenr">44: </span>
<span class="linenr">45: </span>    ! midpoint rule
<span class="linenr">46: </span>    do i = 1,n
<span class="linenr">47: </span>       xi = min + i*dx
<span class="linenr">48: </span>       sum = sum + f(xi)
<span class="linenr">49: </span>    end do
<span class="linenr">50: </span>    sum = sum*dx
<span class="linenr">51: </span>  end function midpoint
<span class="linenr">52: </span>
<span class="linenr">53: </span>end program main
</pre>
</div>

<pre class="example">
n: 2, M_n: .976360
n: 4, M_n: .993575
n: 6, M_n: .997091
n: 8, M_n: .998353
n: 10, M_n: .998942
n: 12, M_n: .999264
n: 14, M_n: .999459
n: 16, M_n: .999585
n: 18, M_n: .999672
n: 20, M_n: .999735
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> Polymorphism</h3>
<div class="outline-text-3" id="text-6-4">
<p>
An <code>interface</code> can be used as an entry into two different implementations of a subroutine or function with the same name so long as the different implementations have different argument signatures. This may be particularly useful for defining both a single precision and double precision version of a function or subroutine.
</p>
</div>
<div id="outline-container-sec-6-4-1" class="outline-4">
<h4 id="sec-6-4-1"><span class="section-number-4">6.4.1</span> Example: machine epsilon</h4>
<div class="outline-text-4" id="text-6-4-1">
<p>
The following code implements two versions of a function that computes machine epsilon in either single or double precision. The different implementations are distinguished by their arguments. The single precision version <code>mach_eps_sp</code> accepts one single precision float and the double precision version <code>mach_eps_dp</code> accepts one double precision float. Both functions are listed in the <code>interface</code> and can be called by its name <code>mach_eps</code>.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  integer, parameter :: sp = kind(0.0)
<span class="linenr"> 5: </span>  integer, parameter :: dp = kind(0.d0)
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>  interface mach_eps
<span class="linenr"> 8: </span>     procedure mach_eps_sp, mach_eps_dp
<span class="linenr"> 9: </span>  end interface mach_eps
<span class="linenr">10: </span>
<span class="linenr">11: </span>  print*, mach_eps(0.0_sp), epsilon(0.0_sp)
<span class="linenr">12: </span>  print*, mach_eps(0.0_dp), epsilon(0.0_dp)
<span class="linenr">13: </span>
<span class="linenr">14: </span>contains
<span class="linenr">15: </span>
<span class="linenr">16: </span>  function mach_eps_sp(x) result(eps)
<span class="linenr">17: </span>    real(sp) :: x, eps
<span class="linenr">18: </span>    integer :: count = 0
<span class="linenr">19: </span>
<span class="linenr">20: </span>    eps = 1.0_sp
<span class="linenr">21: </span>    do while (1.0_sp + eps*0.5 &gt; 1.0_sp)
<span class="linenr">22: </span>       eps = eps*0.5
<span class="linenr">23: </span>       count = count+1
<span class="linenr">24: </span>    end do
<span class="linenr">25: </span>  end function mach_eps_sp
<span class="linenr">26: </span>
<span class="linenr">27: </span>  function mach_eps_dp(x) result(eps)
<span class="linenr">28: </span>    real(dp) :: x, eps
<span class="linenr">29: </span>    integer :: count = 0
<span class="linenr">30: </span>
<span class="linenr">31: </span>    eps = 1.0_dp
<span class="linenr">32: </span>    do while (1.0_dp + eps*0.5 &gt; 1.0_dp)
<span class="linenr">33: </span>       eps = eps*0.5
<span class="linenr">34: </span>       count = count+1
<span class="linenr">35: </span>    end do
<span class="linenr">36: </span>  end function mach_eps_dp
<span class="linenr">37: </span>
<span class="linenr">38: </span>end program main
</pre>
</div>

<pre class="example">
1.19209290E-07   1.19209290E-07
2.2204460492503131E-016   2.2204460492503131E-016
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> Recursion</h3>
<div class="outline-text-3" id="text-6-5">
<p>
A function or subroutine that calls itself must be defined with the <code>recursive</code> keyword preceding the construct name.
</p>
</div>
<div id="outline-container-sec-6-5-1" class="outline-4">
<h4 id="sec-6-5-1"><span class="section-number-4">6.5.1</span> Example: factorial</h4>
<div class="outline-text-4" id="text-6-5-1">
<p>
The following code defines a recursive function <code>factorial</code> that computes \(n!\). If \(n>1\), the function call itself to return \(n(n-1)!\), otherwise the function returns \(1\). The main program calls <code>factorial</code> to compute \(5!\).
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  ! print 5 factorial
<span class="linenr"> 5: </span>  print*, factorial(5)
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>contains
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  ! factorial(n): product of natural numbers up to n
<span class="linenr">10: </span>  ! n: integer argument
<span class="linenr">11: </span>  recursive function factorial(n) result(m)
<span class="linenr">12: </span>    integer :: n, m
<span class="linenr">13: </span>
<span class="linenr">14: </span>    ! if n&gt;1, call factorial recursively
<span class="linenr">15: </span>    ! otherwise 1 factorial is 1
<span class="linenr">16: </span>    if (n&gt;1) then
<span class="linenr">17: </span>       m = n*factorial(n-1)
<span class="linenr">18: </span>    else
<span class="linenr">19: </span>       m = 1
<span class="linenr">20: </span>    end if
<span class="linenr">21: </span>
<span class="linenr">22: </span>  end function factorial
<span class="linenr">23: </span>
<span class="linenr">24: </span>end program main
</pre>
</div>

<pre class="example">
120
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Object-oriented programming</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Derived types</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Data types can be defined by the programmer. Variables and procedures that belong to a defined data type are declared between a <code>type</code> / <code>end type</code> pair. Type-bound procedures, i.e. functions and subroutines, are defined by the <code>procedure</code> keyword followed by <code>::</code> and the name of the procedure within the <code>type</code> / <code>end type</code> pair after the <code>contains</code> keyword. A variable with defined type is declared with the <code>type</code> keyword and the name of the type. The variables and procedures of a defined type variable can be accessed by appending a <code>%</code> symbol to the name of the variable.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>! define a 'matrix' type
<span class="linenr"> 2: </span>! type-bound variables: shape, data
<span class="linenr"> 3: </span>! type-bound procedures: construct, destruct
<span class="linenr"> 4: </span>type matrix
<span class="linenr"> 5: </span>   integer :: shape(2)
<span class="linenr"> 6: </span>   real, allocatable :: data(:,:)
<span class="linenr"> 7: </span> contains
<span class="linenr"> 8: </span>   procedure :: construct
<span class="linenr"> 9: </span>   procedure :: destruct
<span class="linenr">10: </span>end type matrix
<span class="linenr">11: </span>
<span class="linenr">12: </span>! declare a matrix variable
<span class="linenr">13: </span>type(matrix) :: mat
<span class="linenr">14: </span>
<span class="linenr">15: </span>! assign value to type-bound variable
<span class="linenr">16: </span>mat%shape = [3,3]
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Modules</h3>
<div class="outline-text-3" id="text-7-2">
<p>
A type-bound procedure can be defined after the <code>contains</code> keyword in the same program construct, i.e. a <code>module</code>, as the type definition. The first argument in the definition of a type-bound procedure is of the defined type and is declared within the procedure body with the <code>class</code> keyword and the name of the type.
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>module matrix_module
<span class="linenr"> 2: </span>  implicit none
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>  type matrix
<span class="linenr"> 5: </span>     integer :: shape(2)
<span class="linenr"> 6: </span>     real, allocatable :: data(:,:)
<span class="linenr"> 7: </span>   contains
<span class="linenr"> 8: </span>     procedure :: construct
<span class="linenr"> 9: </span>     procedure :: destruct
<span class="linenr">10: </span>  end type matrix
<span class="linenr">11: </span>
<span class="linenr">12: </span>contains
<span class="linenr">13: </span>
<span class="linenr">14: </span>  ! construct: populate shape and allocate memory for matrix
<span class="linenr">15: </span>  ! m,n: number of rows,cols of matrix
<span class="linenr">16: </span>  subroutine construct(this, m, n)
<span class="linenr">17: </span>    class(matrix) :: this
<span class="linenr">18: </span>    integer :: m, n
<span class="linenr">19: </span>    this%shape = [m,n]
<span class="linenr">20: </span>    allocate(this%data(m,n))
<span class="linenr">21: </span>  end subroutine construct
<span class="linenr">22: </span>
<span class="linenr">23: </span>  ! destruct: deallocate memory that matrix occupies
<span class="linenr">24: </span>  subroutine destruct(this)
<span class="linenr">25: </span>    class(matrix) :: this
<span class="linenr">26: </span>    deallocate(this%data)
<span class="linenr">27: </span>  end subroutine destruct
<span class="linenr">28: </span>
<span class="linenr">29: </span>end module matrix_module
</pre>
</div>

<p>
To define variables of the <code>matrix</code> type in the main program, tell it to <code>use</code> the module defined above with <code>use matrix_module</code> immediately after the <code>program main</code> line. The procedures bound to a defined type can be access through variables of that type by appending the <code>%</code> symbol to the name of the variable. 
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  use matrix_module
<span class="linenr"> 3: </span>  implicit none
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  type(matrix) :: mat
<span class="linenr"> 6: </span>  mat%shape = [3,3]
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  ! create matrix
<span class="linenr"> 9: </span>  call mat%construct(3,3)
<span class="linenr">10: </span>
<span class="linenr">11: </span>  ! treat matrix variable 'data' like an array
<span class="linenr">12: </span>  mat%data(1,1) = 1.0
<span class="linenr">13: </span>  ! etc...
<span class="linenr">14: </span>
<span class="linenr">15: </span>  ! destruct matrix
<span class="linenr">16: </span>  call matrix%destruct()
<span class="linenr">17: </span>end program main
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Example: determinant of random matrix</h3>
<div class="outline-text-3" id="text-7-3">
<p>
The following module defines a <code>matrix</code> type with two variables: an <code>integer</code> array <code>shape</code> that stores the number of rows and columns of the matrix and a <code>real</code> array <code>data</code> that stores the elements of the matrix. The type has four procedures: a subroutine <code>construct</code> that sets the shape and allocates memory for the data, a subroutine <code>destruct</code> that deallocates memory, a subroutine <code>print</code> that prints a matrix, and a function <code>det</code> that computes the determinant of a matrix. Note <code>det</code> is based on the definition of determinant using cofactors, and is very inefficient. A function <code>random_matrix</code> defined within the module generates a matrix with uniform random entries in \([-1,1]\).
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">  1: </span>module matrix_module
<span class="linenr">  2: </span>  implicit none
<span class="linenr">  3: </span>
<span class="linenr">  4: </span>  type matrix
<span class="linenr">  5: </span>     integer :: shape(2)
<span class="linenr">  6: </span>     real, allocatable :: data(:,:)
<span class="linenr">  7: </span>   contains
<span class="linenr">  8: </span>     procedure :: construct
<span class="linenr">  9: </span>     procedure :: destruct
<span class="linenr"> 10: </span>     procedure :: print
<span class="linenr"> 11: </span>     procedure :: det
<span class="linenr"> 12: </span>  end type matrix
<span class="linenr"> 13: </span>
<span class="linenr"> 14: </span>contains
<span class="linenr"> 15: </span>
<span class="linenr"> 16: </span>  subroutine construct(this, m, n)
<span class="linenr"> 17: </span>    class(matrix) :: this
<span class="linenr"> 18: </span>    integer :: m,n
<span class="linenr"> 19: </span>    this%shape = [m,n]
<span class="linenr"> 20: </span>    allocate(this%data(m,n))
<span class="linenr"> 21: </span>  end subroutine construct
<span class="linenr"> 22: </span>
<span class="linenr"> 23: </span>  subroutine destruct(this)
<span class="linenr"> 24: </span>    class(matrix) :: this
<span class="linenr"> 25: </span>    deallocate(this%data)
<span class="linenr"> 26: </span>  end subroutine destruct
<span class="linenr"> 27: </span>
<span class="linenr"> 28: </span>  ! print: formatted print of matrix
<span class="linenr"> 29: </span>  subroutine print(this)
<span class="linenr"> 30: </span>    class(matrix) :: this
<span class="linenr"> 31: </span>    ! row_fmt: format character string for row printing
<span class="linenr"> 32: </span>    ! fmt: temporary format string
<span class="linenr"> 33: </span>    character(32) :: row_fmt, fmt = '(a,i0,a,i0,a,i0,a)'
<span class="linenr"> 34: </span>    ! w: width of each entry printed
<span class="linenr"> 35: </span>    ! d: number of decimal digits printed
<span class="linenr"> 36: </span>    integer :: w, d = 2, row
<span class="linenr"> 37: </span>    ! find largest width of element in matrix
<span class="linenr"> 38: </span>    w = ceiling(log10(maxval(abs(this%data)))) + d + 2
<span class="linenr"> 39: </span>    ! write row formatting to 'row_fmt' variable
<span class="linenr"> 40: </span>    write(row_fmt,fmt) '(',this%shape(2),'(f',w,'.',d,',1x))'
<span class="linenr"> 41: </span>    ! print matrix row by row
<span class="linenr"> 42: </span>    do row = 1,this%shape(1)
<span class="linenr"> 43: </span>       print row_fmt, this%data(row,:)
<span class="linenr"> 44: </span>    end do
<span class="linenr"> 45: </span>  end subroutine print
<span class="linenr"> 46: </span>
<span class="linenr"> 47: </span>  ! det: compute determinant of matrix
<span class="linenr"> 48: </span>  ! using recursive definition based on cofactors
<span class="linenr"> 49: </span>  recursive function det(this) result(d)
<span class="linenr"> 50: </span>    class(matrix) :: this
<span class="linenr"> 51: </span>    type(matrix) :: submatrix
<span class="linenr"> 52: </span>    real :: d, sgn, element, minor
<span class="linenr"> 53: </span>    integer :: m, n, row, col, i, j
<span class="linenr"> 54: </span>
<span class="linenr"> 55: </span>    m = this%shape(1)
<span class="linenr"> 56: </span>    n = this%shape(2)
<span class="linenr"> 57: </span>    d = 0.0
<span class="linenr"> 58: </span>
<span class="linenr"> 59: </span>    ! compute cofactor
<span class="linenr"> 60: </span>    ! if 1x1 matrix, return value
<span class="linenr"> 61: </span>    if (m==1.and.n==1) then
<span class="linenr"> 62: </span>       d = this%data(1,1)
<span class="linenr"> 63: </span>    ! if square and not 1x1
<span class="linenr"> 64: </span>    else if (m==n) then
<span class="linenr"> 65: </span>       ! cofactor sum down the first column
<span class="linenr"> 66: </span>       do row = 1,m
<span class="linenr"> 67: </span>	  ! sign of term
<span class="linenr"> 68: </span>	  sgn = (-1.0)**(row+1)
<span class="linenr"> 69: </span>	  ! matrix element
<span class="linenr"> 70: </span>	  element = this%data(row,1)
<span class="linenr"> 71: </span>	  ! construct the cofactor submatrix and compute its determinant
<span class="linenr"> 72: </span>	  call submatrix%construct(m-1,n-1)
<span class="linenr"> 73: </span>	  if (row==1) then
<span class="linenr"> 74: </span>	     submatrix%data = this%data(2:,2:)
<span class="linenr"> 75: </span>	  else if (row==m) then
<span class="linenr"> 76: </span>	     submatrix%data = this%data(:m-1,2:)
<span class="linenr"> 77: </span>	  else
<span class="linenr"> 78: </span>	     submatrix%data(:row-1,:) = this%data(:row-1,2:)
<span class="linenr"> 79: </span>	     submatrix%data(row:,:) = this%data(row+1:,2:)
<span class="linenr"> 80: </span>	  end if
<span class="linenr"> 81: </span>	  minor = submatrix%det()
<span class="linenr"> 82: </span>	  call submatrix%destruct()
<span class="linenr"> 83: </span>
<span class="linenr"> 84: </span>	  ! determinant accumulator
<span class="linenr"> 85: </span>	  d = d + sgn*element*minor
<span class="linenr"> 86: </span>       end do
<span class="linenr"> 87: </span>    end if
<span class="linenr"> 88: </span>  end function det
<span class="linenr"> 89: </span>
<span class="linenr"> 90: </span>  ! random_matrix: generate matrix with random entries in [-1,1]
<span class="linenr"> 91: </span>  ! m,n: number of rows,cols
<span class="linenr"> 92: </span>  function random_matrix(m,n) result(mat)
<span class="linenr"> 93: </span>    integer :: m,n,i,j
<span class="linenr"> 94: </span>    type(matrix) :: mat
<span class="linenr"> 95: </span>    ! allocate memory for matrix
<span class="linenr"> 96: </span>    call mat%construct(m,n)
<span class="linenr"> 97: </span>    ! seed random number generator
<span class="linenr"> 98: </span>    call srand(time())
<span class="linenr"> 99: </span>    ! populate matrix
<span class="linenr">100: </span>    do i = 1,m
<span class="linenr">101: </span>       do j = 1,n
<span class="linenr">102: </span>	  mat%data(i,j) = 2.0*rand() - 1.0
<span class="linenr">103: </span>       end do
<span class="linenr">104: </span>    end do
<span class="linenr">105: </span>  end function random_matrix
<span class="linenr">106: </span>
<span class="linenr">107: </span>end module matrix_module
</pre>
</div>

<p>
The main program uses the <code>matrix_module</code> defined above to find the determinants of a number of random matrices of increasing size. 
</p>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  use matrix_module
<span class="linenr"> 3: </span>  implicit none
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  type(matrix) :: mat
<span class="linenr"> 6: </span>  integer :: n
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  ! compute determinants of random matrices
<span class="linenr"> 9: </span>  do n = 1,5
<span class="linenr">10: </span>     ! generate random  matrix
<span class="linenr">11: </span>     mat = random_matrix(n,n)
<span class="linenr">12: </span>
<span class="linenr">13: </span>     ! print determinant of matrix
<span class="linenr">14: </span>     print "('n: ', i0, ', det: ', f0.5)", n, det(mat)
<span class="linenr">15: </span>
<span class="linenr">16: </span>     ! destruct matrix
<span class="linenr">17: </span>     call mat%destruct()
<span class="linenr">18: </span>  end do
<span class="linenr">19: </span>
<span class="linenr">20: </span>end program main
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">./main
</pre>
</div>

<pre class="example">
n: 1, det: -.68676
n: 2, det: .45054
n: 3, det: .37319
n: 4, det: -.27328
n: 5, det: .26695
</pre>
</div>
</div>

<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4"><span class="section-number-3">7.4</span> Example: matrix module</h3>
<div class="outline-text-3" id="text-7-4">
<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr">  1: </span>module matrix_module
<span class="linenr">  2: </span>  implicit none
<span class="linenr">  3: </span>
<span class="linenr">  4: </span>  public :: zeros
<span class="linenr">  5: </span>  public :: identity
<span class="linenr">  6: </span>  public :: random
<span class="linenr">  7: </span>
<span class="linenr">  8: </span>  type matrix
<span class="linenr">  9: </span>     integer :: shape(2)
<span class="linenr"> 10: </span>     real, allocatable :: data(:,:)
<span class="linenr"> 11: </span>   contains
<span class="linenr"> 12: </span>     procedure :: construct =&gt; matrix_construct
<span class="linenr"> 13: </span>     procedure :: destruct =&gt; matrix_destruct
<span class="linenr"> 14: </span>     procedure :: norm =&gt; matrix_norm
<span class="linenr"> 15: </span>  end type matrix
<span class="linenr"> 16: </span>
<span class="linenr"> 17: </span>  type vector
<span class="linenr"> 18: </span>     integer :: length
<span class="linenr"> 19: </span>     real, allocatable :: data(:)
<span class="linenr"> 20: </span>   contains
<span class="linenr"> 21: </span>     procedure :: construct =&gt; vector_construct
<span class="linenr"> 22: </span>     procedure :: destruct =&gt; vector_destruct
<span class="linenr"> 23: </span>     procedure :: norm =&gt; vector_norm
<span class="linenr"> 24: </span>  end type vector
<span class="linenr"> 25: </span>
<span class="linenr"> 26: </span>  ! assignments
<span class="linenr"> 27: </span>  interface assignment(=)
<span class="linenr"> 28: </span>     procedure vec_num_assign, vec_vec_assign, mat_num_assign, mat_mat_assign
<span class="linenr"> 29: </span>  end interface assignment(=)
<span class="linenr"> 30: </span>
<span class="linenr"> 31: </span>  ! operations
<span class="linenr"> 32: </span>  interface operator(+)
<span class="linenr"> 33: </span>     procedure vec_vec_sum, mat_mat_sum
<span class="linenr"> 34: </span>  end interface operator(+)
<span class="linenr"> 35: </span>
<span class="linenr"> 36: </span>  interface operator(-)
<span class="linenr"> 37: </span>     procedure vec_vec_diff, mat_mat_diff
<span class="linenr"> 38: </span>  end interface operator(-)
<span class="linenr"> 39: </span>
<span class="linenr"> 40: </span>  interface operator(*)
<span class="linenr"> 41: </span>     procedure num_vec_prod, num_mat_prod, mat_vec_prod, mat_mat_prod
<span class="linenr"> 42: </span>  end interface operator(*)
<span class="linenr"> 43: </span>
<span class="linenr"> 44: </span>  interface operator(/)
<span class="linenr"> 45: </span>     procedure vec_num_quot, mat_num_quot
<span class="linenr"> 46: </span>  end interface operator(/)
<span class="linenr"> 47: </span>
<span class="linenr"> 48: </span>  interface operator(**)
<span class="linenr"> 49: </span>     procedure mat_pow
<span class="linenr"> 50: </span>  end interface operator(**)
<span class="linenr"> 51: </span>
<span class="linenr"> 52: </span>  ! functions
<span class="linenr"> 53: </span>  interface norm
<span class="linenr"> 54: </span>     procedure vector_norm, matrix_norm
<span class="linenr"> 55: </span>  end interface norm
<span class="linenr"> 56: </span>
<span class="linenr"> 57: </span>  ! structured vectors/matrices
<span class="linenr"> 58: </span>  interface zeros
<span class="linenr"> 59: </span>     procedure zeros_vector, zeros_matrix
<span class="linenr"> 60: </span>  end interface zeros
<span class="linenr"> 61: </span>
<span class="linenr"> 62: </span>  interface random
<span class="linenr"> 63: </span>     procedure random_vector, random_matrix
<span class="linenr"> 64: </span>  end interface random
<span class="linenr"> 65: </span>
<span class="linenr"> 66: </span>contains
<span class="linenr"> 67: </span>
<span class="linenr"> 68: </span>  subroutine matrix_construct(this, m, n)
<span class="linenr"> 69: </span>    class(matrix) :: this
<span class="linenr"> 70: </span>    integer :: m,n
<span class="linenr"> 71: </span>    this%shape = [m,n]
<span class="linenr"> 72: </span>    allocate(this%data(m,n))
<span class="linenr"> 73: </span>  end subroutine matrix_construct
<span class="linenr"> 74: </span>
<span class="linenr"> 75: </span>  subroutine vector_construct(this, n)
<span class="linenr"> 76: </span>    class(vector) :: this
<span class="linenr"> 77: </span>    integer :: n
<span class="linenr"> 78: </span>    this%length = n
<span class="linenr"> 79: </span>    allocate(this%data(n))
<span class="linenr"> 80: </span>  end subroutine vector_construct
<span class="linenr"> 81: </span>
<span class="linenr"> 82: </span>  subroutine matrix_destruct(this)
<span class="linenr"> 83: </span>    class(matrix) :: this
<span class="linenr"> 84: </span>    deallocate(this%data)
<span class="linenr"> 85: </span>  end subroutine matrix_destruct
<span class="linenr"> 86: </span>
<span class="linenr"> 87: </span>  subroutine vector_destruct(this)
<span class="linenr"> 88: </span>    class(vector) :: this
<span class="linenr"> 89: </span>    deallocate(this%data)
<span class="linenr"> 90: </span>  end subroutine vector_destruct
<span class="linenr"> 91: </span>
<span class="linenr"> 92: </span>  ! assignment
<span class="linenr"> 93: </span>  subroutine vec_num_assign(vec,num)
<span class="linenr"> 94: </span>    type(vector), intent(inout) :: vec
<span class="linenr"> 95: </span>    real, intent(in) :: num
<span class="linenr"> 96: </span>    vec%data = num
<span class="linenr"> 97: </span>  end subroutine vec_num_assign
<span class="linenr"> 98: </span>
<span class="linenr"> 99: </span>  subroutine vec_vec_assign(vec1,vec2)
<span class="linenr">100: </span>    type(vector), intent(inout) :: vec1
<span class="linenr">101: </span>    type(vector), intent(in) :: vec2
<span class="linenr">102: </span>    vec1%data = vec2%data
<span class="linenr">103: </span>  end subroutine vec_vec_assign
<span class="linenr">104: </span>
<span class="linenr">105: </span>  subroutine mat_num_assign(mat,num)
<span class="linenr">106: </span>    type(matrix), intent(inout) :: mat
<span class="linenr">107: </span>    real, intent(in) :: num
<span class="linenr">108: </span>    mat%data = num
<span class="linenr">109: </span>  end subroutine mat_num_assign
<span class="linenr">110: </span>
<span class="linenr">111: </span>  subroutine mat_mat_assign(mat1,mat2)
<span class="linenr">112: </span>    type(matrix), intent(inout) :: mat1
<span class="linenr">113: </span>    type(matrix), intent(in) :: mat2
<span class="linenr">114: </span>    mat1%data = mat2%data
<span class="linenr">115: </span>  end subroutine mat_mat_assign
<span class="linenr">116: </span>
<span class="linenr">117: </span>  ! operations
<span class="linenr">118: </span>  function vec_vec_sum(vec1,vec2) result(s)
<span class="linenr">119: </span>    type(vector), intent(in) :: vec1, vec2
<span class="linenr">120: </span>    type(vector) :: s
<span class="linenr">121: </span>    call s%construct(vec1%length)
<span class="linenr">122: </span>    s%data = vec1%data + vec2%data
<span class="linenr">123: </span>  end function vec_vec_sum
<span class="linenr">124: </span>
<span class="linenr">125: </span>  function mat_mat_sum(mat1,mat2) result(s)
<span class="linenr">126: </span>    type(matrix), intent(in) :: mat1, mat2
<span class="linenr">127: </span>    type(matrix) :: s
<span class="linenr">128: </span>    call s%construct(mat1%shape(1),mat1%shape(2))
<span class="linenr">129: </span>    s%data = mat1%data+mat2%data
<span class="linenr">130: </span>  end function mat_mat_sum
<span class="linenr">131: </span>
<span class="linenr">132: </span>  function vec_vec_diff(vec1,vec2) result(diff)
<span class="linenr">133: </span>    type(vector), intent(in) :: vec1, vec2
<span class="linenr">134: </span>    type(vector) :: diff
<span class="linenr">135: </span>    call diff%construct(vec1%length)
<span class="linenr">136: </span>    diff%data = vec1%data-vec2%data
<span class="linenr">137: </span>  end function vec_vec_diff
<span class="linenr">138: </span>
<span class="linenr">139: </span>  function mat_mat_diff(mat1,mat2) result(diff)
<span class="linenr">140: </span>    type(matrix), intent(in) :: mat1, mat2
<span class="linenr">141: </span>    type(matrix) :: diff
<span class="linenr">142: </span>    call diff%construct(mat1%shape(1),mat1%shape(2))
<span class="linenr">143: </span>    diff%data = mat1%data-mat2%data
<span class="linenr">144: </span>  end function mat_mat_diff
<span class="linenr">145: </span>
<span class="linenr">146: </span>  function num_vec_prod(num,vec) result(prod)
<span class="linenr">147: </span>    real, intent(in) :: num
<span class="linenr">148: </span>    type(vector), intent(in) :: vec
<span class="linenr">149: </span>    type(vector) :: prod
<span class="linenr">150: </span>    call prod%construct(vec%length)
<span class="linenr">151: </span>    prod%data = num*vec%data
<span class="linenr">152: </span>  end function num_vec_prod
<span class="linenr">153: </span>
<span class="linenr">154: </span>  function num_mat_prod(num,mat) result(prod)
<span class="linenr">155: </span>    real, intent(in) :: num
<span class="linenr">156: </span>    type(matrix), intent(in) :: mat
<span class="linenr">157: </span>    type(matrix) :: prod
<span class="linenr">158: </span>    call prod%construct(mat%shape(1),mat%shape(2))
<span class="linenr">159: </span>    prod%data = num*mat%data
<span class="linenr">160: </span>  end function num_mat_prod
<span class="linenr">161: </span>
<span class="linenr">162: </span>  function mat_vec_prod(mat,vec) result(prod)
<span class="linenr">163: </span>    type(matrix), intent(in) :: mat
<span class="linenr">164: </span>    type(vector), intent(in) :: vec
<span class="linenr">165: </span>    type(vector) :: prod
<span class="linenr">166: </span>    call prod%construct(mat%shape(1))
<span class="linenr">167: </span>    prod%data = matmul(mat%data,vec%data)
<span class="linenr">168: </span>  end function mat_vec_prod
<span class="linenr">169: </span>
<span class="linenr">170: </span>  function mat_mat_prod(mat1,mat2) result(prod)
<span class="linenr">171: </span>    type(matrix), intent(in) :: mat1, mat2
<span class="linenr">172: </span>    type(matrix) :: prod
<span class="linenr">173: </span>    call prod%construct(mat1%shape(1),mat2%shape(2))
<span class="linenr">174: </span>    prod%data = matmul(mat1%data,mat2%data)
<span class="linenr">175: </span>  end function mat_mat_prod
<span class="linenr">176: </span>
<span class="linenr">177: </span>  function vec_num_quot(vec,num) result(quot)
<span class="linenr">178: </span>    type(vector), intent(in) :: vec
<span class="linenr">179: </span>    real, intent(in) :: num
<span class="linenr">180: </span>    type(vector) :: quot
<span class="linenr">181: </span>    call quot%construct(vec%length)
<span class="linenr">182: </span>    quot%data = vec%data/num
<span class="linenr">183: </span>  end function vec_num_quot
<span class="linenr">184: </span>
<span class="linenr">185: </span>  function mat_num_quot(mat,num) result(quot)
<span class="linenr">186: </span>    type(matrix), intent(in) :: mat
<span class="linenr">187: </span>    real, intent(in) :: num
<span class="linenr">188: </span>    type(matrix) :: quot
<span class="linenr">189: </span>    call quot%construct(mat%shape(1),mat%shape(2))
<span class="linenr">190: </span>    quot%data = mat%data/num
<span class="linenr">191: </span>  end function mat_num_quot
<span class="linenr">192: </span>
<span class="linenr">193: </span>  function mat_pow(mat1,pow) result(mat2)
<span class="linenr">194: </span>    type(matrix), intent(in) :: mat1
<span class="linenr">195: </span>    integer, intent(in) :: pow
<span class="linenr">196: </span>    type(matrix) :: mat2
<span class="linenr">197: </span>    integer :: i
<span class="linenr">198: </span>    mat2 = mat1
<span class="linenr">199: </span>    do i = 2,pow
<span class="linenr">200: </span>       mat2 = mat1*mat2
<span class="linenr">201: </span>    end do
<span class="linenr">202: </span>  end function mat_pow
<span class="linenr">203: </span>
<span class="linenr">204: </span>  ! functions
<span class="linenr">205: </span>  function vector_norm(this,p) result(mag)
<span class="linenr">206: </span>    class(vector), intent(in) :: this
<span class="linenr">207: </span>    integer, intent(in) :: p
<span class="linenr">208: </span>    real :: mag
<span class="linenr">209: </span>    integer :: i
<span class="linenr">210: </span>    ! inf-norm
<span class="linenr">211: </span>    if (p==0) then
<span class="linenr">212: </span>       mag = 0.0
<span class="linenr">213: </span>       do i = 1,this%length
<span class="linenr">214: </span>	  mag = max(mag,abs(this%data(i)))
<span class="linenr">215: </span>       end do
<span class="linenr">216: </span>    ! p-norm
<span class="linenr">217: </span>    else if (p&gt;0) then
<span class="linenr">218: </span>       mag = (sum(abs(this%data)**p))**(1./p)
<span class="linenr">219: </span>    end if
<span class="linenr">220: </span>  end function vector_norm
<span class="linenr">221: </span>
<span class="linenr">222: </span>  function matrix_norm(this, p) result(mag)
<span class="linenr">223: </span>    class(matrix), intent(in) :: this
<span class="linenr">224: </span>    integer, intent(in) :: p
<span class="linenr">225: </span>    real ::  mag, tol = 1e-6
<span class="linenr">226: </span>    integer :: m, n, row, col, iter, max_iters = 1000
<span class="linenr">227: </span>    type(vector) :: vec, last_vec
<span class="linenr">228: </span>    m = size(this%data(:,1)); n = size(this%data(1,:))
<span class="linenr">229: </span>
<span class="linenr">230: </span>    ! entry-wise norms
<span class="linenr">231: </span>    if (p&lt;0) then
<span class="linenr">232: </span>       mag = (sum(abs(this%data)**(-p)))**(-1./p)
<span class="linenr">233: </span>    ! inf-norm
<span class="linenr">234: </span>    else if (p==0) then
<span class="linenr">235: </span>       mag = 0.0
<span class="linenr">236: </span>       do row = 1,m
<span class="linenr">237: </span>	  mag = max(mag,sum(abs(this%data(row,:))))
<span class="linenr">238: </span>       end do
<span class="linenr">239: </span>    ! 1-norm
<span class="linenr">240: </span>    else if (p==1) then
<span class="linenr">241: </span>       mag = 0.0
<span class="linenr">242: </span>       do col = 1,n
<span class="linenr">243: </span>	  mag = max(mag,sum(abs(this%data(:,col))))
<span class="linenr">244: </span>       end do
<span class="linenr">245: </span>    ! p-norm
<span class="linenr">246: </span>    else if (p&gt;0) then
<span class="linenr">247: </span>       vec = random(n)
<span class="linenr">248: </span>       vec = vec/vec%norm(p)
<span class="linenr">249: </span>       last_vec = zeros(n)
<span class="linenr">250: </span>       mag = 0.0
<span class="linenr">251: </span>       do iter = 1,max_iters
<span class="linenr">252: </span>	  last_vec = vec
<span class="linenr">253: </span>	  vec = this*last_vec
<span class="linenr">254: </span>	  vec = vec/vec%norm(p)
<span class="linenr">255: </span>	  if (vector_norm(vec-last_vec,p)&lt;tol) exit
<span class="linenr">256: </span>       end do
<span class="linenr">257: </span>       mag = vector_norm(this*vec,p)
<span class="linenr">258: </span>    end if
<span class="linenr">259: </span>  end function matrix_norm
<span class="linenr">260: </span>
<span class="linenr">261: </span>  ! structured vectors/matrices
<span class="linenr">262: </span>  function random_matrix(m,n) result(mat)
<span class="linenr">263: </span>    integer :: m,n
<span class="linenr">264: </span>    type(matrix) :: mat
<span class="linenr">265: </span>    call mat%construct(m,n)
<span class="linenr">266: </span>    call random_seed()
<span class="linenr">267: </span>    call random_number(mat%data)
<span class="linenr">268: </span>  end function random_matrix
<span class="linenr">269: </span>
<span class="linenr">270: </span>  function random_vector(n) result(vec)
<span class="linenr">271: </span>    integer :: n
<span class="linenr">272: </span>    type(vector) :: vec
<span class="linenr">273: </span>    call vec%construct(n)
<span class="linenr">274: </span>    call random_seed()
<span class="linenr">275: </span>    call random_number(vec%data)
<span class="linenr">276: </span>  end function random_vector
<span class="linenr">277: </span>
<span class="linenr">278: </span>  function zeros_vector(n) result(vec)
<span class="linenr">279: </span>    integer :: n
<span class="linenr">280: </span>    type(vector) :: vec
<span class="linenr">281: </span>    call vec%construct(n)
<span class="linenr">282: </span>    vec = 0.0
<span class="linenr">283: </span>  end function zeros_vector
<span class="linenr">284: </span>
<span class="linenr">285: </span>  function zeros_matrix(m,n) result(mat)
<span class="linenr">286: </span>    integer :: m,n
<span class="linenr">287: </span>    type(matrix) :: mat
<span class="linenr">288: </span>    call mat%construct(m,n)
<span class="linenr">289: </span>    mat = 0.0
<span class="linenr">290: </span>  end function zeros_matrix
<span class="linenr">291: </span>
<span class="linenr">292: </span>  function identity(m,n) result(mat)
<span class="linenr">293: </span>    integer :: m,n,i
<span class="linenr">294: </span>    type(matrix) :: mat
<span class="linenr">295: </span>    call mat%construct(m,n)
<span class="linenr">296: </span>    do i = 1,min(m,n)
<span class="linenr">297: </span>       mat%data(i,i) = 1.0
<span class="linenr">298: </span>    end do
<span class="linenr">299: </span>  end function identity
<span class="linenr">300: </span>
<span class="linenr">301: </span>end module matrix_module
</pre>
</div>

<div class="org-src-container">

<pre class="src src-fortran"><span class="linenr"> 1: </span>program main
<span class="linenr"> 2: </span>  use matrix_module
<span class="linenr"> 3: </span>  implicit none
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  type(vector) :: vec1, vec2
<span class="linenr"> 6: </span>  type(matrix) :: mat1, mat2
<span class="linenr"> 7: </span>  real :: x
<span class="linenr"> 8: </span>  integer :: i
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  ! 0s, id, random
<span class="linenr">11: </span>  mat1 = zeros(3,3)
<span class="linenr">12: </span>  call mat1%destruct()
<span class="linenr">13: </span>  mat1 = identity(3,3)
<span class="linenr">14: </span>  mat2 = random(3,3)
<span class="linenr">15: </span>  mat1 = mat1*mat1
<span class="linenr">16: </span>  vec1 = zeros(3)
<span class="linenr">17: </span>  call vec1%destruct()
<span class="linenr">18: </span>  vec1 = random(3)
<span class="linenr">19: </span>  vec2 = random(3)
<span class="linenr">20: </span>  ! +,-,*,/,**
<span class="linenr">21: </span>  mat1 = mat1+mat2
<span class="linenr">22: </span>  vec1 = vec1+vec2
<span class="linenr">23: </span>  mat1 = mat1-mat2
<span class="linenr">24: </span>  vec1 = vec1-vec2
<span class="linenr">25: </span>  vec1 = mat1*vec2
<span class="linenr">26: </span>  mat1 = mat2*mat1
<span class="linenr">27: </span>  mat1 = 2.0*mat1
<span class="linenr">28: </span>  vec1 = 2.0*vec1
<span class="linenr">29: </span>  mat1 = mat1/2.0
<span class="linenr">30: </span>  vec1 = vec1/2.0
<span class="linenr">31: </span>  mat2 = mat1**3
<span class="linenr">32: </span>  ! norm
<span class="linenr">33: </span>  x = norm(vec1,0)
<span class="linenr">34: </span>  x = norm(vec1,1)
<span class="linenr">35: </span>  x = norm(mat1,-1)
<span class="linenr">36: </span>  x = norm(mat1,0)
<span class="linenr">37: </span>  x = norm(mat1,1)
<span class="linenr">38: </span>  x = norm(mat1,2)
<span class="linenr">39: </span>  call vec1%destruct
<span class="linenr">40: </span>  call vec2%destruct
<span class="linenr">41: </span>  call mat1%destruct
<span class="linenr">42: </span>  call mat2%destruct
<span class="linenr">43: </span>end program main
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">./main
</pre>
</div>

<pre class="example">
2          14   1.03737926       3.62866984E-07
3          10  0.976910591       1.07453801E-07
4           9   1.84589541       2.06476543E-07
5          10   2.39860868       2.45756240E-07
</pre>

<p>
:snippets:
</p>
<p>
:end:
</p>

</div>
</div>
</div>
</div>
</div>
</body>
</html>
