<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>ACM Computing Seminar C++ Guide</title>
<!-- 2017-10-02 Mon 20:33 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Matt Hancock" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/main.css">
<script src="../js/main.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=Tex-AMS-MML_HTMLorMML"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">ACM Computing Seminar C++ Guide</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Introduction</a>
<ul>
<li><a href="#sec-1-1">1.1. A little about the language</a></li>
<li><a href="#sec-1-2">1.2. Additional references</a></li>
<li><a href="#sec-1-3">1.3. License, source, etc.</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Getting started</a>
<ul>
<li><a href="#sec-2-1">2.1. Text editors</a></li>
<li><a href="#sec-2-2">2.2. Compilers</a></li>
<li><a href="#sec-2-3">2.3. Writing a program</a></li>
</ul>
</li>
<li><a href="#sec-3">3. Data types</a>
<ul>
<li><a href="#sec-3-1">3.1. The <code>bool</code> type</a></li>
<li><a href="#sec-3-2">3.2. <code>int</code> types</a></li>
<li><a href="#sec-3-3">3.3. Floating point types</a></li>
<li><a href="#sec-3-4">3.4. Casting</a></li>
<li><a href="#sec-3-5">3.5. The <code>const</code> modifier</a></li>
<li><a href="#sec-3-6">3.6. The <code>typedef</code> keyword</a></li>
<li><a href="#sec-3-7">3.7. Pointers and references</a>
<ul>
<li><a href="#sec-3-7-1">3.7.1. Pointers</a></li>
<li><a href="#sec-3-7-2">3.7.2. References</a></li>
</ul>
</li>
<li><a href="#sec-3-8">3.8. Arrays</a>
<ul>
<li><a href="#sec-3-8-1">3.8.1. Fixed length arrays</a></li>
<li><a href="#sec-3-8-2">3.8.2. Dynamic length arrays</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. Control structures</a>
<ul>
<li><a href="#sec-4-1">4.1. Conditionals</a>
<ul>
<li><a href="#sec-4-1-1">4.1.1. Example: <code>if</code> / <code>else</code> and random number generation</a></li>
<li><a href="#sec-4-1-2">4.1.2. Example: <code>if</code> / <code>else if</code> / <code>else</code></a></li>
</ul>
</li>
<li><a href="#sec-4-2">4.2. Loops</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1. The <code>for</code> loop</a>
<ul>
<li><a href="#sec-4-2-1-1">4.2.1.1. Example: row-major matrix</a></li>
</ul>
</li>
<li><a href="#sec-4-2-2">4.2.2. The <code>while</code> loop</a>
<ul>
<li><a href="#sec-4-2-2-1">4.2.2.1. Example: truncated sum</a></li>
<li><a href="#sec-4-2-2-2">4.2.2.2. Example: estimating machine epsilon</a></li>
</ul>
</li>
<li><a href="#sec-4-2-3">4.2.3. The <code>break</code> keyword</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">5. Input / Output</a>
<ul>
<li><a href="#sec-5-1">5.1. Inputs to <code>main</code>: <code>argc</code> and <code>argv</code></a></li>
<li><a href="#sec-5-2">5.2. Filestreams</a>
<ul>
<li><a href="#sec-5-2-1">5.2.1. Reading data from a file</a></li>
<li><a href="#sec-5-2-2">5.2.2. Writing data to a file</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. Functions</a>
<ul>
<li><a href="#sec-6-1">6.1. Writing a function</a>
<ul>
<li><a href="#sec-6-1-1">6.1.1. Example: <code>linspace</code>: generating a set of equally-spaced points</a></li>
</ul>
</li>
<li><a href="#sec-6-2">6.2. Header and implementation files</a>
<ul>
<li><a href="#sec-6-2-1">6.2.1. The header file</a></li>
<li><a href="#sec-6-2-2">6.2.2. The implementation file</a></li>
<li><a href="#sec-6-2-3">6.2.3. The file containing <code>main</code></a></li>
</ul>
</li>
<li><a href="#sec-6-3">6.3. Function pointers</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1. Example: Newton's method for rootfinding</a></li>
<li><a href="#sec-6-3-2">6.3.2. Example: The midpoint rule for definite integrals</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7">7. Object-oriented programming</a>
<ul>
<li><a href="#sec-7-1">7.1. Example: a vector <code>class</code></a>
<ul>
<li><a href="#sec-7-1-1">7.1.1. The header file</a></li>
<li><a href="#sec-7-1-2">7.1.2. The implementation file</a></li>
<li><a href="#sec-7-1-3">7.1.3. Example usage</a></li>
<li><a href="#sec-7-1-4">7.1.4. Operator overloading</a>
<ul>
<li><a href="#sec-7-1-4-1">7.1.4.1. Overloading <code>operator[]</code></a></li>
<li><a href="#sec-7-1-4-2">7.1.4.2. Overloading <code>operator=</code></a></li>
</ul>
</li>
<li><a href="#sec-7-1-5">7.1.5. The copy constructor</a></li>
<li><a href="#sec-7-1-6">7.1.6. Friend functions</a>
<ul>
<li><a href="#sec-7-1-6-1">7.1.6.1. Overloading <code>operator*</code></a></li>
<li><a href="#sec-7-1-6-2">7.1.6.2. Overloading <code>operator&lt;&lt;</code></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-7-2">7.2. Templating: a matrix class</a>
<ul>
<li><a href="#sec-7-2-1">7.2.1. Overloading <code>operator*</code></a></li>
</ul>
</li>
<li><a href="#sec-7-3">7.3. Inheritance</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="main">
<div id="footer"><a href="../../../">ACM Computing Seminar Home</a> &mdash; This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.en_US">Creative Commons Attribution 3.0 Unported License</a>.</div>
<a href="javascript:;" id="toc-open">&#9776;</a>
<a href="javascript:;" id="toc-close">&times;</a>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
This manual is a guide for quickly learning C++ for mathematical and 
scientific computing applications. The goal of this guide is not to 
make you a C++ expert, but to quickly teach you enough of the C++ 
fundamentals and design patterns to help you off the ground. If you 
should like to go beyond this guide, a few references are listed below.
</p>
</div>

<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> A little about the language</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Before you dive in, here is a little about the C++ programming language:
</p>

<p>
C++ is an extension of the C programming language. Both C and C++ are 
<b>statically-typed</b> and <b>compiled</b> languages, which means that the <b>type</b> 
of variables used in your source code must be declared explicitly and is 
checked when the program is compiled (i.e., translated into a machine 
executable file).
</p>

<p>
One key difference between C++ and C, however, is that C++ provides 
many mechanisms to allow for the <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming paradigm</a>. This 
essentially allows the software writer to create custom, complex, 
reusable data structures. The object-oriented paradigm is extremely useful, 
but we will only touch the surface of it in this guide.
</p>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Additional references</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li><a href="http://cppreference.com">C++ reference</a>
</li>
<li><a href="http://www.cplusplus.com/doc/tutorial">C++ tutorials</a>
</li>
<li><a href="https://en.wikipedia.org/wiki/C++">C++ wiki</a>
</li>
<li><a href="http://stackoverflow.com/questions/388242/the-definitive-c-book-guide-and-list">A compiled list of C++ textbooks from stackoverflow</a>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> License, source, etc.</h3>
<div class="outline-text-3" id="text-1-3">
<p>
This document was created using <a href="https://www.gnu.org/software/emacs/">Emacs</a> <a href="http://orgmode.org/">org mode</a> with some custom css and 
javascript. You can find the license, view the source, and contribute 
to this document here:
</p>

<p>
<a href="https://github.com/notmatthancock/acm-computing-seminar"><a href="https://github.com/notmatthancock/acm-computing-seminar">https://github.com/notmatthancock/acm-computing-seminar</a></a>
</p>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Getting started</h2>
<div class="outline-text-2" id="text-2">
<p>
The particular programming tools that you choose to use will
likely be largely influenced by the operating system that you use.
We will use free tools (often developed for GNU / Linux systems) in
this guide. These tools are mostly available in other operating 
systems as well. For example, on Windows, you could use <a href="https://www.cygwin.com/">Cygwin</a>, or 
install a dual boot with some Linux distribution (e.g., <a href="http://www.ubuntu.com/">Ubuntu</a>). On the 
other hand, MAC OSX, being a BSD-derived system, has many of the 
required tools already available (although, a command line utility, 
<a href="http://brew.sh">Brew</a>, makes building and installing other tools very simple).
</p>

<p>
In the following two sections, we'll talk about the two basic types of 
software that you'll need to begin writing C++ programs.
</p>
</div>

<div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Text editors</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The text editor that you choose to use should be be any program 
capable of editing plain text files. However, you may find that it's 
more productive to write in an editor that offers features such as 
syntax highlighting, code-completion, bracket-matching, or other features. 
Here are some popular free text editors:
</p>

<ul class="org-ul">
<li><a href="https://atom.io/">Atom</a> is a recently open-sourced GUI editor which some have compared to the very popular non-free editor, <a href="https://sublimetext.com">Sublime Text</a>.
</li>
<li><a href="https://www.gnu.org/software/emacs/">Emacs</a> is another powerful editor, which allows for highly optimized workflows.
</li>
<li><a href="https://wiki.gnome.org/Apps/Gedit">Gedit</a> is a nice and simple GUI editor, which is the default in GNOME desktop environment.
</li>
<li><a href="https://kate-editor.org">Kate</a> is a another simple GUI editor, which is the default in the KDE desktop environment.
</li>
<li><a href="http://www.vim.org">Vim</a> is a modal editor with a steep learning curve. It offers highly efficient means to edit text, and is available (or it's predecessor, vi) by default on nearly all UNIX-like operating systems.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Compilers</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Second, you'll need a program called a <b>compiler</b>. A compiler translates 
the high-level C++ language into an executable program. In this guide, we 
will use the <code>g++</code> compiler which is freely available through the 
<a href="https://gcc.gnu.org/">gnu compiler collection (gcc)</a>.
</p>

<p>
<code>g++</code> is a program which you typically call from the command line, which 
takes as input, your C++ source code file, and produces as output, a 
binary executable file.
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> Writing a program</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Let's create our first C++ program, the obligatory "Hello, world!". First, 
fire-up your text editor and create a file called, <code>hello.cpp</code>, with the 
following contents:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>#include &lt;iostream&gt;
<span class="linenr">2: </span>
<span class="linenr">3: </span>int main() {
<span class="linenr">4: </span>  std::cout &lt;&lt; "Hello, world!";
<span class="linenr">5: </span>  return 0;
<span class="linenr">6: </span>}
</pre>
</div>

<p>
Now, to compile the program, execute:
</p>

<div class="org-src-container">

<pre class="src src-sh">g++ hello.cpp
</pre>
</div>

<p>
Followed by:
</p>
<div class="org-src-container">

<pre class="src src-sh">./a.out
</pre>
</div>

<p>
By default, <code>g++</code> names the resulting binary executable, <code>a.out</code>, but
you can specify a different output file name by using the <code>-o</code> flag:
</p>

<div class="org-src-container">

<pre class="src src-sh">g++ hello.cpp -o my_executable_file.bin
</pre>
</div>

<p>
Note that in Windows, executable files typically end in <code>.exe</code>. In Unix-like
systems, there is no particular file-extension type for executables.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Data types</h2>
<div class="outline-text-2" id="text-3">
<p>
As we <a href="#sec-1-1">mentioned previously</a>, you must explicitly declare the type of a 
variable. So, in this section, we'll talk about the main variable 
types you'll use. In the section on <a href="#sec-7">object-oriented programming</a>, 
we'll discuss how to build more complex data types.
</p>
</div>

<div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> The <code>bool</code> type</h3>
<div class="outline-text-3" id="text-3-1">
<p>
A boolean data type is either <code>true</code> or <code>false</code>. There are a number of 
operators between these types, illustrated in the code snippet below 
(note that lines starting with <code>//</code> are comments and are ignored by the 
compiler):
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>bool a,b,c; // Declare the type of variables a, b, and c.
<span class="linenr"> 2: </span>a = true;
<span class="linenr"> 3: </span>b = false;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>// !  is logical negation when applied to a single variable.
<span class="linenr"> 6: </span>c = !a; // c is false.
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>// &amp;&amp; is logical and.
<span class="linenr"> 9: </span>c = (a &amp;&amp; b); // c is false.
<span class="linenr">10: </span>
<span class="linenr">11: </span>// || is logical or.
<span class="linenr">12: </span>c = (a || b); // c is true.
</pre>
</div>

<p>
We don't often use boolean variables by themselves, but rather as a result 
of comparing two other data types (such as comparing if one integer is less 
than another integer). Expressions that result in boolean values are mostly 
used in <a href="#sec-4-1">conditional control structures</a>.
</p>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> <code>int</code> types</h3>
<div class="outline-text-3" id="text-3-2">
<p>
There are <a href="http://en.cppreference.com/w/cpp/language/types">a variety of integer types</a> in C++. Below, we illustrate a 
couple. These can be modified further using the <code>short</code> and <code>long</code> 
keywords, changing the number of bytes occupied by the variable (and 
hence the maximum and minimum size the variable can take on).
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>int a = 6; // initialize a to 6.
<span class="linenr"> 2: </span>unsigned int b = 7; // initialize b to 7.
<span class="linenr"> 3: </span>int c; // declare c to be an integer variable.
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>a = 6;
<span class="linenr"> 6: </span>b = 7;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>c = a / b; // c is 0
<span class="linenr"> 9: </span>c = b / a; // c is 1
<span class="linenr">10: </span>c = b % a; // c is 1 (% is the integer remainder or modulo operator)
<span class="linenr">11: </span>c = a - b; // c is -1
<span class="linenr">12: </span>c = a &gt; b; // c is 0 (boolean gets cast to integer)
<span class="linenr">13: </span>c = a &lt; b; // c is 1 (boolean gets cast to integer)
<span class="linenr">14: </span>c++;       // c is 2 (++ is shorthand for c = c + 1)
<span class="linenr">15: </span>
<span class="linenr">16: </span>b = a - b; // b is 4294967295 (-1 gets cast to unsigned)
<span class="linenr">17: </span>b = b + 1; // b is 0 (b was previously the largest unsigned,
<span class="linenr">18: </span>	   // so adding one circles it back to zero.)
<span class="linenr">19: </span>b += 7;    // b is 7 (+= is shorthand for b = b + 7;
</pre>
</div>

<p>
In the above, we've illustrated the use of signed and unsigned 
integer types and the operators between them. It is important to 
take care when you assign a result to a variable that doesn't match 
the type of the result. In many cases, the result gets implicitly 
cast to the type of variable being assigned to. The result may or 
may not match your expectations, as shown above.
</p>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Floating point types</h3>
<div class="outline-text-3" id="text-3-3">
<p>
There are two main floating point data types in C++, <code>float</code> and <code>double</code>,
which correspond to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 32- and 64-bit floating point types</a>. 
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include &lt;limits&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>  float a; //  Declare a single precision float.
<span class="linenr"> 6: </span>  double b; // Declare a double precision float.
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  // Print the max value of a float type.
<span class="linenr"> 9: </span>  std::cout &lt;&lt; std::numeric_limits&lt;float&gt;::max() &lt;&lt; std::endl;
<span class="linenr">10: </span>
<span class="linenr">11: </span>  // Print the max value of a double type.
<span class="linenr">12: </span>  std::cout &lt;&lt; std::numeric_limits&lt;double&gt;::max() &lt;&lt; std::endl;
<span class="linenr">13: </span>
<span class="linenr">14: </span>  // Print machine epsilon of a float type.
<span class="linenr">15: </span>  std::cout &lt;&lt; std::numeric_limits&lt;float&gt;::epsilon() &lt;&lt; std::endl;
<span class="linenr">16: </span>
<span class="linenr">17: </span>  // Print machine epsilon of a double type.
<span class="linenr">18: </span>  std::cout &lt;&lt; std::numeric_limits&lt;double&gt;::epsilon() &lt;&lt; std::endl;
<span class="linenr">19: </span>
<span class="linenr">20: </span>  return 0;
<span class="linenr">21: </span>}
</pre>
</div>

<pre class="example">
3.40282e+38
1.79769e+308
1.19209e-07
2.22045e-16
</pre>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Casting</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Sometimes it is useful to explicitly cast one variable type as another. 
This can be done like the following:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>int a; double b = 3.14159;
<span class="linenr">2: </span>
<span class="linenr">3: </span>a = (int) b;
<span class="linenr">4: </span>
<span class="linenr">5: </span>std::cout &lt;&lt; a &lt;&lt; std::endl;
</pre>
</div>

<pre class="example">
3
</pre>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> The <code>const</code> modifier</h3>
<div class="outline-text-3" id="text-3-5">
<p>
If the value of some variable should not change, you can use the <code>const</code>
keyword to protect its status. It is typical to denote <code>const</code> variables 
with all caps. Try to compile the following program:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>const double PI = 3.14159;
<span class="linenr">2: </span>
<span class="linenr">3: </span>PI = 3.0;
</pre>
</div>

<p>
You will see an error like, <code>error: assignment of read-only variable ‘PI’</code>. 
</p>
</div>
</div>

<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> The <code>typedef</code> keyword</h3>
<div class="outline-text-3" id="text-3-6">
<p>
Suppose you have a large numerical experiment, where all your code used 
floating point of type <code>double</code>. Your curious about how the results will 
be affected by changing the floating point type to single precision <code>float</code>
type. One solution would be to run a "find and replace" in your editor, but 
something about that doesn't feel right.
</p>

<p>
Instead, we can use the <code>typedef</code> statement to define types:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>// Define "int_type" to be a short int.
<span class="linenr"> 2: </span>typedef short int int_type;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>// Define "float_type" to be single precision float.
<span class="linenr"> 5: </span>typedef float float_type;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>// Define "array_index_type" to be unsigned long int.
<span class="linenr"> 8: </span>typedef unsigned long int array_index_type;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>int_type a = -17; 
<span class="linenr">11: </span>float_type b = 1.14; 
<span class="linenr">12: </span>array_index_type c = 9;
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7"><span class="section-number-3">3.7</span> Pointers and references</h3>
<div class="outline-text-3" id="text-3-7">
</div><div id="outline-container-sec-3-7-1" class="outline-4">
<h4 id="sec-3-7-1"><span class="section-number-4">3.7.1</span> Pointers</h4>
<div class="outline-text-4" id="text-3-7-1">
<p>
Pointers are variables that hold the <b>memory address</b> for a variable 
of a specific type. Pointers are declared by specifying the variable 
type, followed by the <code>*</code> symbol, followed by the name of the pointer 
variable, e.g., <code>double * x</code> defines a "pointer to double" variable. 
The variable, <code>x</code>, therefore, does not hold the value of a <code>double</code> 
type, but rather, the memory address for a variable of type, <code>double</code>.
The memory address for a variable can be obtained by the <code>&amp;</code> operator.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>double * a;
<span class="linenr">2: </span>double b = 7;
<span class="linenr">3: </span>
<span class="linenr">4: </span>// This obtains the memory address of `b`.
<span class="linenr">5: </span>a = &amp;b;
<span class="linenr">6: </span>
<span class="linenr">7: </span>// Prints some memory address (starts with 0x)
<span class="linenr">8: </span>std::cout &lt;&lt; a &lt;&lt; std::endl;
</pre>
</div>

<pre class="example">
0x7ffe0d98f7b8
</pre>

<p>
Similar to obtaining the memory address from a regular variable, using the
<code>&amp;</code> operator, you can use the <code>*</code> symbol before a pointer to access the 
variable value held at the memory location of the pointer. In this context,
the <code>*</code> symbol is called the <b>dereference operator</b>. This is probably better 
understood with a short example:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>double * a;
<span class="linenr"> 2: </span>double b = 7.3;
<span class="linenr"> 3: </span>double c;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>// Now `a` holds the memory address of `b`.
<span class="linenr"> 6: </span>a = &amp;b;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>// `*a` obtains the value of the variable
<span class="linenr"> 9: </span>// at the memory address held by `a`.
<span class="linenr">10: </span>// So, `c` is 7.3.
<span class="linenr">11: </span>c = *a;
<span class="linenr">12: </span>
<span class="linenr">13: </span>std::cout &lt;&lt; c &lt;&lt; "\n";
</pre>
</div>

<pre class="example">
7.3
</pre>
</div>
</div>

<div id="outline-container-sec-3-7-2" class="outline-4">
<h4 id="sec-3-7-2"><span class="section-number-4">3.7.2</span> References</h4>
<div class="outline-text-4" id="text-3-7-2">
<p>
A reference is a sort of like a pointer, but not quite. <a href="https://en.wikipedia.org/wiki/Reference_(C++)">There are differences</a>.
A good analogy, which you can find in the previous link, is that a reference
is similar to a symbolic link, or "shortcut" if you're on Windows. You can 
treat it more-or-less like the original variable, but it's not the original.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>double a = 1.1;
<span class="linenr"> 2: </span>// `b` is a reference to `a`.
<span class="linenr"> 3: </span>double &amp; b = a;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; "\n";
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>a = 2.1;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; "\n";
<span class="linenr">10: </span>
<span class="linenr">11: </span>b = 3.1;
<span class="linenr">12: </span>
<span class="linenr">13: </span>std::cout &lt;&lt; "a: " &lt;&lt; a &lt;&lt; ", b: " &lt;&lt; b &lt;&lt; "\n";
<span class="linenr">14: </span>
<span class="linenr">15: </span>std::cout &lt;&lt; "\n\n";
<span class="linenr">16: </span>std::cout &lt;&lt; "&amp;a: " &lt;&lt; &amp;a &lt;&lt; "\n" &lt;&lt; "&amp;b: " &lt;&lt; &amp;b &lt;&lt; "\n";
</pre>
</div>

<pre class="example">
a: 1.1, b: 1.1
a: 2.1, b: 2.1
a: 3.1, b: 3.1


&amp;a: 0x7ffcfbe7b1e8
&amp;b: 0x7ffcfbe7b1e8
</pre>

<p>
References are useful for passing around large objects, so that the object
doesn't need to be copied. References are also useful as a return type for 
functions <a href="#sec-6">(to be discussed later)</a> because it allows to assign to assign a 
value to a function, which is useful if the function, for example, returns 
a reference to the element of an array.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-3-8" class="outline-3">
<h3 id="sec-3-8"><span class="section-number-3">3.8</span> Arrays</h3>
<div class="outline-text-3" id="text-3-8">
<p>
The length of an array can be fixed or dynamic, and how you
declare the array depends on this. Array indexing starts at 0 in C++ 
(compared to start at 1, for example, in Fortran or Matlab).
</p>
</div>

<div id="outline-container-sec-3-8-1" class="outline-4">
<h4 id="sec-3-8-1"><span class="section-number-4">3.8.1</span> Fixed length arrays</h4>
<div class="outline-text-4" id="text-3-8-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>double a[5];
<span class="linenr">2: </span>
<span class="linenr">3: </span>a[0] = 1.0;
<span class="linenr">4: </span>// etc.
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-3-8-2" class="outline-4">
<h4 id="sec-3-8-2"><span class="section-number-4">3.8.2</span> Dynamic length arrays</h4>
<div class="outline-text-4" id="text-3-8-2">
<p>
Dynamic length arrays are made possible through pointers:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>// This allocates memory for 5 double types.
<span class="linenr"> 2: </span>double * a = new double[5];
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>// Afterwards, you can treat `a` like a normal array.
<span class="linenr"> 5: </span>a[0] = 1.0;
<span class="linenr"> 6: </span>// etc...
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>// Whenever you use the `new` keyword, you must
<span class="linenr"> 9: </span>// delete the memory allocated when you're done by hand.
<span class="linenr">10: </span>delete [] a;
<span class="linenr">11: </span>
<span class="linenr">12: </span>// We can change the size of `a`.
<span class="linenr">13: </span>a = new double [10];
<span class="linenr">14: </span>
<span class="linenr">15: </span>a[0] = 2.0;
<span class="linenr">16: </span>// etc...
<span class="linenr">17: </span>
<span class="linenr">18: </span>delete [] a;
</pre>
</div>

<p>
Note that omitting the first <code>delete</code> statement will cause no error. 
However, the memory allocated by the first <code>new</code> statement will not 
be freed, and thus inaccessible. This is bad because the memory cannot 
be allocated to other resources. You should generally try to avoid 
manually memory management when possible, but a good tool for debugging 
memory problems is called <a href="http://valgrind.org/">valgrind</a>. 
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Control structures</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Conditionals</h3>
<div class="outline-text-3" id="text-4-1">
</div><div id="outline-container-sec-4-1-1" class="outline-4">
<h4 id="sec-4-1-1"><span class="section-number-4">4.1.1</span> Example: <code>if</code> / <code>else</code> and random number generation</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Often a code block should only be executed if some condition is true. 
Below, we generate a random number between 0 and 1; print the number; and,
print whether or not the number was greater than 0.5.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include &lt;stdlib.h&gt;
<span class="linenr"> 3: </span>#include &lt;time.h&gt;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>int main() {
<span class="linenr"> 6: </span>  // Seed a random number generator.
<span class="linenr"> 7: </span>  srand(123);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  // rand() produces a random integer between 0 and RAND_MAX.
<span class="linenr">10: </span>  double num = rand() / ((double) RAND_MAX);
<span class="linenr">11: </span>
<span class="linenr">12: </span>  std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n";
<span class="linenr">13: </span>
<span class="linenr">14: </span>  if (num &lt; 0.5) {
<span class="linenr">15: </span>    std::cout &lt;&lt; "num was less than 0.5.\n";
<span class="linenr">16: </span>  }
<span class="linenr">17: </span>  else {
<span class="linenr">18: </span>    std::cout &lt;&lt; "num was greater than 0.5.\n";
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>
<span class="linenr">21: </span>  // Do it again.
<span class="linenr">22: </span>  num = rand() / ((double) RAND_MAX);
<span class="linenr">23: </span>
<span class="linenr">24: </span>  std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n";
<span class="linenr">25: </span>
<span class="linenr">26: </span>  if (num &lt; 0.5) {
<span class="linenr">27: </span>    std::cout &lt;&lt; "num was less than 0.5.\n";
<span class="linenr">28: </span>  }
<span class="linenr">29: </span>  else {
<span class="linenr">30: </span>    std::cout &lt;&lt; "num was greater than 0.5.\n";
<span class="linenr">31: </span>  }
<span class="linenr">32: </span>
<span class="linenr">33: </span>  return 0;
<span class="linenr">34: </span>}
</pre>
</div>

<pre class="example">
num: 0.0600514
num was less than 0.5.
num: 0.788318
num was greater than 0.5.
</pre>
</div>
</div>

<div id="outline-container-sec-4-1-2" class="outline-4">
<h4 id="sec-4-1-2"><span class="section-number-4">4.1.2</span> Example: <code>if</code> / <code>else if</code> / <code>else</code></h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
You can follow <code>else</code> immediate by another <code>if</code> to have multiple mutually-
exclusive blocks:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include &lt;stdlib.h&gt;
<span class="linenr"> 3: </span>#include &lt;time.h&gt;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>int main() {
<span class="linenr"> 6: </span>  // Seed the random number generator based on the current time.
<span class="linenr"> 7: </span>  srand(time(NULL));
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  // rand() produces a random integer between 0 and RAND_MAX.
<span class="linenr">10: </span>  double num = rand() / ((double) RAND_MAX);
<span class="linenr">11: </span>
<span class="linenr">12: </span>  std::cout &lt;&lt; "num: " &lt;&lt; num &lt;&lt; "\n";
<span class="linenr">13: </span>
<span class="linenr">14: </span>  if (num &gt;= 0.75) {
<span class="linenr">15: </span>    std::cout &lt;&lt; "num was between 0.75 and 1.\n";
<span class="linenr">16: </span>  }
<span class="linenr">17: </span>  else if (num &gt;= 0.5) {
<span class="linenr">18: </span>    std::cout &lt;&lt; "num was between 0.5 and 0.75.";
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>  else if (num &gt;= 0.25) {
<span class="linenr">21: </span>    std::cout &lt;&lt; "num was between 0.25 and 0.5.";
<span class="linenr">22: </span>  }
<span class="linenr">23: </span>  else {
<span class="linenr">24: </span>    std::cout &lt;&lt; "num was between 0 and 0.25";
<span class="linenr">25: </span>  }
<span class="linenr">26: </span>
<span class="linenr">27: </span>  return 0;
<span class="linenr">28: </span>}
</pre>
</div>

<pre class="example">
num: 0.0456405
num was between 0 and 0.25
</pre>

<p>
The conditions are checked in the order that they're written. So, for example,
in the second condition, we don't need to specify <code>num &gt;= 0.5 &amp;&amp; num &lt; 0.75</code> 
because we know that this condition will only be checked if the previous 
was false.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Loops</h3>
<div class="outline-text-3" id="text-4-2">
<p>
We discuss two main structures for iterating &#x2013; the <code>for</code> and <code>while</code> loops.
</p>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> The <code>for</code> loop</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
The <code>for</code> loop requires three specifications &#x2013; the iteration variable 
initialization, the termination condition, and the update rule. The body
of the loop follows these three specifications. Shown below, we declare 
an array; assign to its components; and, print the current component to 
the screen.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>int length = 11;
<span class="linenr"> 2: </span>double x[length];
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>for(int i=0; i &lt; length; i++) {
<span class="linenr"> 5: </span>  // Assign to each array component.
<span class="linenr"> 6: </span>  x[i] = (double) i / (length - 1);
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  // Print the current component.
<span class="linenr"> 9: </span>  std::cout &lt;&lt; "x[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; x[i] &lt;&lt; std::endl;
<span class="linenr">10: </span>}
</pre>
</div>

<pre class="example">
x[0] = 0
x[1] = 0.1
x[2] = 0.2
x[3] = 0.3
x[4] = 0.4
x[5] = 0.5
x[6] = 0.6
x[7] = 0.7
x[8] = 0.8
x[9] = 0.9
x[10] = 1
</pre>
</div>


<div id="outline-container-sec-4-2-1-1" class="outline-5">
<h5 id="sec-4-2-1-1"><span class="section-number-5">4.2.1.1</span> Example: row-major matrix</h5>
<div class="outline-text-5" id="text-4-2-1-1">
<p>
You can nest loops, i.e., loops inside of loops, etc.
</p>

<p>
Below, is an example of a double loop for creating and accessing 
matrix data stored in a flat array. The matrix data is stored in 
<a href="https://en.wikipedia.org/wiki/Row-major-order">row-major order</a>. This means the first <code>n_cols</code> elements of the 
array named, <code>matrix</code>, will contain the first row of the matrix, 
the second <code>n_cols</code> elements of <code>matrix</code> will contain the second row, etc.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>int n_rows = 4;
<span class="linenr"> 2: </span>int n_cols = 3;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>// Row-major matrix array.
<span class="linenr"> 5: </span>double matrix [n_rows*n_cols];
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>// temporary index.
<span class="linenr"> 8: </span>int k;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>for(int i=0; i &lt; n_rows; i++) {
<span class="linenr">11: </span>  for(int j=0; j &lt; n_cols; j++) {
<span class="linenr">12: </span>    // Convert the (i,j) matrix index to the "flat" row-major index.
<span class="linenr">13: </span>    k = i*n_cols + j;
<span class="linenr">14: </span>
<span class="linenr">15: </span>    // Assign a value of 1.0 to the diagonal,
<span class="linenr">16: </span>    // 2 to the off-diagonal, and 0 otherwise.
<span class="linenr">17: </span>    if (i == j) {
<span class="linenr">18: </span>      matrix[k] = 1.0;
<span class="linenr">19: </span>    }
<span class="linenr">20: </span>    else if ((i == (j+1)) || (i == (j-1))){
<span class="linenr">21: </span>      matrix[k] = 2.0;
<span class="linenr">22: </span>    }
<span class="linenr">23: </span>    else {
<span class="linenr">24: </span>      matrix[k] = 0.0;
<span class="linenr">25: </span>    }
<span class="linenr">26: </span>  }
<span class="linenr">27: </span>}
<span class="linenr">28: </span>
<span class="linenr">29: </span>
<span class="linenr">30: </span>// Print the matrix elements.
<span class="linenr">31: </span>for(int i=0; i &lt; n_rows; i++) {
<span class="linenr">32: </span>  for(int j=0; j &lt; n_cols; j++) {
<span class="linenr">33: </span>    k = i*n_cols + j;
<span class="linenr">34: </span>
<span class="linenr">35: </span>    std::cout &lt;&lt; matrix[k];
<span class="linenr">36: </span>    if (j != (n_cols-1)) {
<span class="linenr">37: </span>      std::cout &lt;&lt; ", ";
<span class="linenr">38: </span>    }
<span class="linenr">39: </span>  }
<span class="linenr">40: </span>
<span class="linenr">41: </span>  if (i != (n_rows-1)) {
<span class="linenr">42: </span>    std::cout &lt;&lt; "\n";
<span class="linenr">43: </span>  }
<span class="linenr">44: </span>}
</pre>
</div>

<pre class="example">
1, 2, 0
2, 1, 2
0, 2, 1
0, 0, 2
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2"><span class="section-number-4">4.2.2</span> The <code>while</code> loop</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
A <code>while</code> loop iterates while a condition is <code>true</code>. Essentially, it is a <code>for</code>
loop without an update variable.
</p>
</div>

<div id="outline-container-sec-4-2-2-1" class="outline-5">
<h5 id="sec-4-2-2-1"><span class="section-number-5">4.2.2.1</span> Example: truncated sum</h5>
<div class="outline-text-5" id="text-4-2-2-1">
<p>
In the following example, we approximate the geometric series:
</p>

<p>
$$
1 = \sum_{n=1}^{\infty} \left(\frac{1}{2}\right)^n
$$
</p>

<p>
The loop exits when the absolute error, 
</p>

<p>
$$
    \text{absolute error} := 1-\sum_{n=1}^N  \left(\frac{1}{2}\right)^n
$$
</p>

<p>
is less than some specified tolerance, <code>tol</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>double sum = 0.0;
<span class="linenr"> 2: </span>double base = 0.5;
<span class="linenr"> 3: </span>double pow = base; // initialize to base^1
<span class="linenr"> 4: </span>double tol = 1e-4;
<span class="linenr"> 5: </span>int iter = 1;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>while((1-sum) &gt;= tol) {
<span class="linenr"> 8: </span>  // Add `pow` to `sum`.
<span class="linenr"> 9: </span>  sum += pow;
<span class="linenr">10: </span>  // Update `pow` by one power of `base`.
<span class="linenr">11: </span>  pow *= base;
<span class="linenr">12: </span>
<span class="linenr">13: </span>  printf("Iter: %03d, Sum: %.5f, Abs Err: %.5f\n", iter, sum, 1-sum); 
<span class="linenr">14: </span>
<span class="linenr">15: </span>  // Update the `iter` val by 1.
<span class="linenr">16: </span>  iter += 1;
<span class="linenr">17: </span>}
</pre>
</div>

<pre class="example">
Iter: 001, Sum: 0.50000, Abs Err: 0.50000
Iter: 002, Sum: 0.75000, Abs Err: 0.25000
Iter: 003, Sum: 0.87500, Abs Err: 0.12500
Iter: 004, Sum: 0.93750, Abs Err: 0.06250
Iter: 005, Sum: 0.96875, Abs Err: 0.03125
Iter: 006, Sum: 0.98438, Abs Err: 0.01562
Iter: 007, Sum: 0.99219, Abs Err: 0.00781
Iter: 008, Sum: 0.99609, Abs Err: 0.00391
Iter: 009, Sum: 0.99805, Abs Err: 0.00195
Iter: 010, Sum: 0.99902, Abs Err: 0.00098
Iter: 011, Sum: 0.99951, Abs Err: 0.00049
Iter: 012, Sum: 0.99976, Abs Err: 0.00024
Iter: 013, Sum: 0.99988, Abs Err: 0.00012
Iter: 014, Sum: 0.99994, Abs Err: 0.00006
</pre>
</div>
</div>

<div id="outline-container-sec-4-2-2-2" class="outline-5">
<h5 id="sec-4-2-2-2"><span class="section-number-5">4.2.2.2</span> Example: estimating machine epsilon</h5>
<div class="outline-text-5" id="text-4-2-2-2">
<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>double eps = 1;
<span class="linenr"> 2: </span>int count = 1;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>while(1.0 + eps*0.5 &gt; 1.0) {
<span class="linenr"> 5: </span>    eps *= 0.5;
<span class="linenr"> 6: </span>    count += 1;
<span class="linenr"> 7: </span>}
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>std::cout &lt;&lt; eps &lt;&lt; ", " &lt;&lt; std::numeric_limits&lt;double&gt;::epsilon() &lt;&lt; "\n"
<span class="linenr">10: </span>	  &lt;&lt; count &lt;&lt; ", " &lt;&lt; std::numeric_limits&lt;double&gt;::digits;
</pre>
</div>

<pre class="example">
2.22045e-16, 2.22045e-16
53, 53
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3"><span class="section-number-4">4.2.3</span> The <code>break</code> keyword</h4>
<div class="outline-text-4" id="text-4-2-3">
<p>
The <code>break</code> keyword provides a mechanism for exiting the direct parent loop
for which the <code>break</code> statement is placed. For example:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>for(int i=0; i &lt; 3; i++) {
<span class="linenr">2: </span>  while(true) {
<span class="linenr">3: </span>    std::cout &lt;&lt; "Entering infinite loop number " &lt;&lt; (i+1) &lt;&lt; "\n";
<span class="linenr">4: </span>    break;
<span class="linenr">5: </span>  }
<span class="linenr">6: </span>  std::cout &lt;&lt; "We escaped the infinite loop!\n";
<span class="linenr">7: </span>}
</pre>
</div>

<pre class="example">
Entering infinite loop number 1
We escaped the infinite loop!
Entering infinite loop number 2
We escaped the infinite loop!
Entering infinite loop number 3
We escaped the infinite loop!
</pre>

<p>
The previous example is contrived, but there are situations, where you
might find the break statement within an infinite loop useful. Of course,
you should avoid this sort of thing if there is a more straight-forward 
approach.
</p>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> Input / Output</h2>
<div class="outline-text-2" id="text-5">
<p>
We have already used the <code>&lt;iostream&gt;</code> library to print results to 
the console. However, in many cases, we'd like to read in lots of 
data from a file, pass option flags to the program from the command 
line, or save the results of some computation to a file for further 
analysis.
</p>
</div>

<div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Inputs to <code>main</code>: <code>argc</code> and <code>argv</code></h3>
<div class="outline-text-3" id="text-5-1">
<p>
The <code>main</code> function has two optional arguments which we have thus far omitted, 
<code>argc</code> and <code>argv</code>. These arguments allow arguments to passed to the <code>main</code> 
function when the program is run. This is how flags and other arguments are 
passed to programs you use from the command line. The first, <code>argc</code>, is of 
type, <code>int</code>, and stands for arg count. It gives the number of arguments 
to the program. The arg count is always at least 1 because the program's 
name is always the first argument. The second, <code>argv</code>, is a double pointer to
<code>char</code>. In essence, <code>argv</code> is an array of strings.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>int main(int argc, char ** argv) {
<span class="linenr"> 4: </span>  std::cout &lt;&lt; "argc = " &lt;&lt; argc &lt;&lt; "\n";
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>  for(int i=0; i &lt; argc; i++) {
<span class="linenr"> 7: </span>    std::cout &lt;&lt; "argv[" &lt;&lt; i &lt;&lt; "] = " &lt;&lt; argv[i] &lt;&lt; "\n";
<span class="linenr"> 8: </span>  }
<span class="linenr"> 9: </span>  return 0;
<span class="linenr">10: </span>}
</pre>
</div>

<p>
Compile this program, and run, for example:
</p>

<div class="org-src-container">

<pre class="src src-bash">g++ main.cpp
./a.out hello 1 2 34
</pre>
</div>

<pre class="example">
argc = 5
argv[0] = ./a.out
argv[1] = hello
argv[2] = 1
argv[3] = 2
argv[4] = 34
</pre>

<p>
<code>argc</code> and <code>argv</code> are handy for setting up large experiments. You could, for 
example, set up your main function so that different functions or parameters 
or used based on the arguments of <code>arcv</code>. Then, you could set up a shell 
script that loops through the desired arguments to be supplied to the main 
function.
</p>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Filestreams</h3>
<div class="outline-text-3" id="text-5-2">
<p>
File input and output is crucial for numerical experiments with lots of data. 
In this section, we see how to read and write data to files.
</p>
</div>

<div id="outline-container-sec-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> Reading data from a file</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
In general, how data is read in depends heavily on how the data is stored. 
Nevertheless, we will give an example of reading in a vector stored in a 
particular fashion. Suppose a text file exists in the directory, 
<code>./data/vector.txt</code>, containing
</p>

<pre class="example">
1 2 3.14 4 5 6.28
</pre>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include &lt;fstream&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    std::fstream fin("./data/vector.txt", std::ios_base::in);
<span class="linenr"> 6: </span>    double vector[6];
<span class="linenr"> 7: </span>    int i = 0;
<span class="linenr"> 8: </span>    while(fin &gt;&gt; vector[i]) {
<span class="linenr"> 9: </span>      std::cout &lt;&lt; vector[i] &lt;&lt; " ";
<span class="linenr">10: </span>      i++;
<span class="linenr">11: </span>    }
<span class="linenr">12: </span>    return 0;
<span class="linenr">13: </span>}
</pre>
</div>

<div class="org-src-container">

<pre class="src src-sh">g++ main.cpp &amp;&amp; ./a.out
</pre>
</div>

<pre class="example">
1 2 3.14 4 5 6.28
</pre>

<p>
This simply prints the data in the file back out to the console. Note, however, 
that the data is read into an array of type <code>double</code>, so it can be processed 
numerically thereafter.
</p>

<p>
In this example dealt with simply stored data, and it was 
assumed that the number of data entries was known beforehand. Parsing 
data can become quite complicated depending on how it is stored, and 
depending on the intended format of the data.
</p>
</div>
</div>

<div id="outline-container-sec-5-2-2" class="outline-4">
<h4 id="sec-5-2-2"><span class="section-number-4">5.2.2</span> Writing data to a file</h4>
<div class="outline-text-4" id="text-5-2-2">
<p>
Writing to a file is similar, using the <code>&lt;fstream&gt;</code> library.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;fstream&gt;
<span class="linenr"> 2: </span>#include &lt;cmath&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>  std::fstream fout("./data/new_shiny_data.txt", std::ios_base::out);
<span class="linenr"> 6: </span>  double x;
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  fout &lt;&lt; "x\tsin(x)\n";
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>  for(int i=0; i &lt; 11; i++) {
<span class="linenr">11: </span>    x = i / 10.0;
<span class="linenr">12: </span>    fout &lt;&lt; x &lt;&lt; "\t" &lt;&lt; sin(x) &lt;&lt; "\n";
<span class="linenr">13: </span>  }
<span class="linenr">14: </span>
<span class="linenr">15: </span>  fout.close();
<span class="linenr">16: </span>
<span class="linenr">17: </span>  return 0;
<span class="linenr">18: </span>}
</pre>
</div>

<p>
This produces a file called <code>new_shiny_data.txt</code> in the folder, <code>data</code>, 
containing:
</p>

<div class="org-src-container">

<pre class="src src-sh">x       sin(x)
0       0
0.1     0.0998334
0.2     0.198669
0.3     0.29552
0.4     0.389418
0.5     0.479426
0.6     0.564642
0.7     0.644218
0.8     0.717356
0.9     0.783327
1       0.841471
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Functions</h2>
<div class="outline-text-2" id="text-6">
<p>
So far, we've piled everything into the <code>main</code> function. When we have a block of 
code used for a specific subtask, we can offload it to a function. This promotes 
code which is separated based on the subtasks each block is intended to perform. 
This, in turn, makes your code easier to debug and easier to understand.  
</p>
</div>

<div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Writing a function</h3>
<div class="outline-text-3" id="text-6-1">
<p>
A function must be declared before use. Thus, a function usual consists of two
parts, a declaration and an implementation. You must declare the return type 
of a function as well as the types of all the function's arguments. If the 
function is defined in the same file as the <code>main</code> function, you should write
the declaration before <code>main</code> and the implementation after <code>main</code>.
</p>
</div>

<div id="outline-container-sec-6-1-1" class="outline-4">
<h4 id="sec-6-1-1"><span class="section-number-4">6.1.1</span> Example: <code>linspace</code>: generating a set of equally-spaced points</h4>
<div class="outline-text-4" id="text-6-1-1">
<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>// This is the function declaration.
<span class="linenr"> 4: </span>// You should describe the functions arguments
<span class="linenr"> 5: </span>// and what is returned by the function in comments
<span class="linenr"> 6: </span>// near the declaration.
<span class="linenr"> 7: </span>//
<span class="linenr"> 8: </span>// `linspace` returns an array of doubles containing
<span class="linenr"> 9: </span>// `n_points` entries which are equally-spaced, starting
<span class="linenr">10: </span>// at `start` and ending at `stop`.
<span class="linenr">11: </span>double * linspace(double start, double stop, int n_points);
<span class="linenr">12: </span>
<span class="linenr">13: </span>// `void` is a function with no return type.
<span class="linenr">14: </span>// `print_array` takes an array and prints it to std out.
<span class="linenr">15: </span>void print_array(double * arr, int arr_len);
<span class="linenr">16: </span>
<span class="linenr">17: </span>int main() {
<span class="linenr">18: </span>  double * xs = linspace(-1, 1, 5);
<span class="linenr">19: </span>  print_array(xs, 5);
<span class="linenr">20: </span>  delete [] xs;
<span class="linenr">21: </span>
<span class="linenr">22: </span>  return 0;
<span class="linenr">23: </span>}
<span class="linenr">24: </span>
<span class="linenr">25: </span>// Implementation of `linspace`.
<span class="linenr">26: </span>double * linspace(double start, double stop, int n_points) {
<span class="linenr">27: </span>  double * arr = new double [n_points];
<span class="linenr">28: </span>  double dx = (stop-start) / (n_points-1.0);
<span class="linenr">29: </span>
<span class="linenr">30: </span>  for(int i=0; i &lt; n_points; i++) {
<span class="linenr">31: </span>    arr[i] = start + i*dx;
<span class="linenr">32: </span>  }
<span class="linenr">33: </span>
<span class="linenr">34: </span>  return arr;
<span class="linenr">35: </span>}
<span class="linenr">36: </span>
<span class="linenr">37: </span>// Implementation of `print_array`.
<span class="linenr">38: </span>void print_array(double * arr, int arr_len) {
<span class="linenr">39: </span>  for(int i=0; i &lt; arr_len; i++) {
<span class="linenr">40: </span>    std::cout &lt;&lt; arr[i] &lt;&lt; "\n";
<span class="linenr">41: </span>  }
<span class="linenr">42: </span>}
</pre>
</div>

<pre class="example">
-1
-0.5
0
0.5
1
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> Header and implementation files</h3>
<div class="outline-text-3" id="text-6-2">
<p>
The example in the previous section certainly made the <code>main</code> function
cleaner and simpler to understand, having only two function calls. However, 
the file itself was still pretty messy. Thankfully, there is a way to modularize 
further, by creating header and implementation files. Here is how we do it:
</p>
</div>

<div id="outline-container-sec-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> The header file</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
Put the declarations from the into a header file, called <code>my_library.h</code>:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#ifndef MY_LIBRARY_H
<span class="linenr"> 2: </span>#define MY_LIBRARY_H
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>#include &lt;iostream&gt;
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>namespace my_namespace {
<span class="linenr"> 7: </span>    // `linspace` returns an array of doubles containing
<span class="linenr"> 8: </span>    // `n_points` entries which are equally-spaced, starting
<span class="linenr"> 9: </span>    // at `start` and ending at `stop`.
<span class="linenr">10: </span>    double * linspace(double start, double stop, int n_points);
<span class="linenr">11: </span>
<span class="linenr">12: </span>    // `void` is a function with no return type.
<span class="linenr">13: </span>    // `print_array` takes an array and prints it to std out.
<span class="linenr">14: </span>    void print_array(double * arr, int arr_len);
<span class="linenr">15: </span>}
<span class="linenr">16: </span>
<span class="linenr">17: </span>#endif
</pre>
</div>

<p>
Note the the function declarations are wrapped in conditional "macro" 
statments, <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>. You can think of this 
as protecting your library from being imported twice.
</p>

<p>
We have also introduced the notion of a <code>namespace</code> above. Namespaces 
help to prevent naming clashes between separate libraries. When calling 
a function from a particular namespace, you must write the namespace 
followed by <code>::</code> and then the function name. This is why many standard 
library functions like <code>&lt;iostream&gt;</code> begin with <code>std::</code>.
</p>
</div>
</div>

<div id="outline-container-sec-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> The implementation file</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
Create a file called <code>my_library.cpp</code> containing the implementations as follows:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include "my_library.h"
<span class="linenr"> 2: </span>
<span class="linenr"> 3: </span>// Implementation of `linspace`.
<span class="linenr"> 4: </span>double * my_namespace::linspace(double start, double stop, int n_points) {
<span class="linenr"> 5: </span>  double * arr = new double [n_points];
<span class="linenr"> 6: </span>  double dx = (stop-start) / (n_points-1.0);
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>  for(int i=0; i &lt; n_points; i++) {
<span class="linenr"> 9: </span>    arr[i] = start + i*dx;
<span class="linenr">10: </span>  }
<span class="linenr">11: </span>
<span class="linenr">12: </span>  return arr;
<span class="linenr">13: </span>}
<span class="linenr">14: </span>
<span class="linenr">15: </span>// Implementation of `print_array`.
<span class="linenr">16: </span>void my_namespace::print_array(double * arr, int arr_len) {
<span class="linenr">17: </span>  for(int i=0; i &lt; arr_len; i++) {
<span class="linenr">18: </span>    std::cout &lt;&lt; arr[i] &lt;&lt; "\n";
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>}
</pre>
</div>

<p>
Note that we have to include the header file in quotations at the beginning, 
and the names of the functions must be prepended by the namespace that we've 
given in the header file.
</p>
</div>
</div>

<div id="outline-container-sec-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> The file containing <code>main</code></h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
Create a file with the main function, say <code>main.cpp</code>:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "my_library.h"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    double * xs = my_namespace::linspace(-1,1,5);
<span class="linenr"> 6: </span>    my_namespace::print_array(xs, 5);
<span class="linenr"> 7: </span>    delete [] xs;
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    return 0;
<span class="linenr">10: </span>}
</pre>
</div>

<p>
Now the main function is very nice and clean, but now we 3 separate files we 
must compile into one executable. This is done as follows:
</p>

<div class="org-src-container">

<pre class="src src-bash"># Convert the library into an object file.
g++ -c my_library.cpp
# Compile the main to an executable.
g++ my_library.o main.cpp
# Run it.
./a.out
</pre>
</div>

<pre class="example">
-1
-0.5
0
0.5
1
</pre>

<p>
If successful, you will see the same output <a href="#sec-6-1">as previously</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> Function pointers</h3>
<div class="outline-text-3" id="text-6-3">
<p>
Pointers can be made to functions, and these function pointers can be used 
as arguments to other functions. We'll look at two functions that accept a 
function pointer as one of their arguments.
</p>
</div>

<div id="outline-container-sec-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> Example: Newton's method for rootfinding</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
Suppose \(f: \mathbb{R} \to \mathbb{R}\), and we'd like to find a root of \(f\). 
Newton's method is an iterative method for finding roots, which, starting 
from some initial guess, \(x_0\), iterates:
</p>

<p>
$$
    x_{n+1} \leftarrow x_n - \frac{f(x_n)}{f'(x_n)}
$$
</p>

<p>
For simplicity, we'll dump everything into the file containing <code>main</code>, but
you could imagine a libary with many methods for finding roots, which would 
contain Newton's method.
</p>

<p>
Let's consider \(f(x) = x^2 - 2\).
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;cmath&gt;
<span class="linenr"> 2: </span>#include &lt;iostream&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>// The function to find the root of.
<span class="linenr"> 5: </span>double func(double x);
<span class="linenr"> 6: </span>// Its derivative.
<span class="linenr"> 7: </span>double dfunc(double x);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>// Find the root of `f` using Newton's method,
<span class="linenr">10: </span>// starting from `x0` until |f(x)| &lt; `tol` or `max_iters`
<span class="linenr">11: </span>// is reached.
<span class="linenr">12: </span>//
<span class="linenr">13: </span>// Note the first and second arguments are function pointers.
<span class="linenr">14: </span>double newton_root(double (*f)(double), double (*df)(double), double x0,
<span class="linenr">15: </span>		   double tol, int max_iters, bool print_iters); 
<span class="linenr">16: </span>
<span class="linenr">17: </span>int main() {
<span class="linenr">18: </span>  double x = newton_root(&amp;func, &amp;dfunc, 1.0, 1e-6, 1000, true);
<span class="linenr">19: </span>
<span class="linenr">20: </span>  return 0;
<span class="linenr">21: </span>}
<span class="linenr">22: </span>
<span class="linenr">23: </span>double func( double x) { return x*x - 2; }
<span class="linenr">24: </span>double dfunc(double x) { return 2*x; }
<span class="linenr">25: </span>
<span class="linenr">26: </span>double newton_root(double (*f)(double), double (*df)(double), double x0,
<span class="linenr">27: </span>		   double tol, int max_iters, bool print_iters) {
<span class="linenr">28: </span>  double x  = x0;
<span class="linenr">29: </span>  int iter  = 0;
<span class="linenr">30: </span>
<span class="linenr">31: </span>  while (std::abs(f(x)) &gt; tol &amp;&amp; iter &lt; max_iters) {
<span class="linenr">32: </span>    if (print_iters) { 
<span class="linenr">33: </span>      std::cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; f(x) &lt;&lt; "\n";
<span class="linenr">34: </span>    }
<span class="linenr">35: </span>
<span class="linenr">36: </span>    // Newton's method update.
<span class="linenr">37: </span>    x -= f(x) / df(x);
<span class="linenr">38: </span>    iter++;
<span class="linenr">39: </span>  }
<span class="linenr">40: </span>
<span class="linenr">41: </span>  // One last print if necessary.
<span class="linenr">42: </span>  if (print_iters) { 
<span class="linenr">43: </span>    std::cout &lt;&lt; "f(" &lt;&lt; x &lt;&lt; ") = " &lt;&lt; f(x) &lt;&lt; "\n";
<span class="linenr">44: </span>  }
<span class="linenr">45: </span>
<span class="linenr">46: </span>  return x;
<span class="linenr">47: </span>}
</pre>
</div>

<pre class="example">
f(1) = -1
f(1.5) = 0.25
f(1.41667) = 0.00694444
f(1.41422) = 6.0073e-06
f(1.41421) = 4.51061e-12
</pre>
</div>
</div>

<div id="outline-container-sec-6-3-2" class="outline-4">
<h4 id="sec-6-3-2"><span class="section-number-4">6.3.2</span> Example: The midpoint rule for definite integrals</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
The midpoint rule is a numerical integration method which approximates 
the definite integral of a specified function over a specified interval 
using a specified number of subintervals where on each subinterval, the 
area under the curve is approximated by a rectangle whose width is the 
width of the subinterval and whose height is the height of the function 
at the midpoint between the points defining the end points of the subinterval.
</p>

<p>
Specifically, if \(n\) equally-sized subintervals are used on \([a,b]\), then
the midpoint rule approximation, \(M_n\), to the definite integral of \(f(x)\) 
on \([a,b]\) is: 
</p>

<p>
$$
    \int_a^b f(x) \; dx \approx \sum_{i=1}^n f\left( \frac{x_{i-1}+x_i}{2} \right) \Delta x =: M_n
$$
</p>

<p>
where \(\Delta x = \frac{b-a}{n}\), and \(x_i = a + i \cdot \Delta x, \;\; i=0, 1, \ldots, n\).
</p>

<p>
Let's consider \(f(x) = \frac{1}{x}\) on \([1, e]\).
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include &lt;cmath&gt;
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>const double E = std::exp(1.0);
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>// The function to be integrated.
<span class="linenr"> 7: </span>double func(double x);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>// Compute the midpoint rule approximation to
<span class="linenr">10: </span>// the definite integral of `f` from `a` to `b`
<span class="linenr">11: </span>// using `n` subintervals.
<span class="linenr">12: </span>double midpoint_rule(double (*f)(double), double a, double b, int n);
<span class="linenr">13: </span>
<span class="linenr">14: </span>
<span class="linenr">15: </span>int main() {
<span class="linenr">16: </span>  for(int n=2; n &lt;= 20; n += 2) {
<span class="linenr">17: </span>    std::cout &lt;&lt; "n = " &lt;&lt; n &lt;&lt; ", "
<span class="linenr">18: </span>	      &lt;&lt; "M_n = " &lt;&lt; midpoint_rule(&amp;func, 1, E, n) &lt;&lt; "\n";
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>
<span class="linenr">21: </span>  return 0;
<span class="linenr">22: </span>}
<span class="linenr">23: </span>
<span class="linenr">24: </span>double func(double x) { return 1.0 / x; }
<span class="linenr">25: </span>
<span class="linenr">26: </span>double midpoint_rule(double (*f)(double), double a, double b, int n) {
<span class="linenr">27: </span>  double xi;
<span class="linenr">28: </span>  double xi_prev = a;
<span class="linenr">29: </span>  double dx = (b-a) / n;
<span class="linenr">30: </span>  double sum;
<span class="linenr">31: </span>
<span class="linenr">32: </span>  for(int i=1; i &lt;= n; i++) {
<span class="linenr">33: </span>    xi = a + i*dx;
<span class="linenr">34: </span>    sum += f(0.5*(xi_prev + xi));
<span class="linenr">35: </span>    xi_prev = xi;
<span class="linenr">36: </span>  }
<span class="linenr">37: </span>
<span class="linenr">38: </span>  return sum*dx;
<span class="linenr">39: </span>}
</pre>
</div>

<pre class="example">
n = 2, M_n = 0.97636
n = 4, M_n = 0.993575
n = 6, M_n = 0.997091
n = 8, M_n = 0.998353
n = 10, M_n = 0.998942
n = 12, M_n = 0.999264
n = 14, M_n = 0.999459
n = 16, M_n = 0.999585
n = 18, M_n = 0.999672
n = 20, M_n = 0.999734
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Object-oriented programming</h2>
<div class="outline-text-2" id="text-7">
<p>
New data types can be created by writing a new <code>class</code>. A <code>class</code> has 
state variables and functions that act on the state variables. An instance 
of a <code>class</code> is called an <b>object</b>. Let's write a <code>vector</code> class that 
improves upon the default <code>double</code> array.
</p>
</div>

<div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Example: a vector <code>class</code></h3>
<div class="outline-text-3" id="text-7-1">
</div><div id="outline-container-sec-7-1-1" class="outline-4">
<h4 id="sec-7-1-1"><span class="section-number-4">7.1.1</span> The header file</h4>
<div class="outline-text-4" id="text-7-1-1">
<p>
Create the header file, <code>vector.h</code>:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#ifndef VECTOR_H
<span class="linenr"> 2: </span>#define VECTOR_H
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>namespace vec {
<span class="linenr"> 5: </span>  class vector {
<span class="linenr"> 6: </span>  public:
<span class="linenr"> 7: </span>    // Constructor. This function is called when the object is created.
<span class="linenr"> 8: </span>    vector(unsigned len);
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    // Destructor. This function is called when the object is destroyed.
<span class="linenr">11: </span>    ~vector();
<span class="linenr">12: </span>
<span class="linenr">13: </span>    // length accessor.
<span class="linenr">14: </span>    unsigned len() const;
<span class="linenr">15: </span>
<span class="linenr">16: </span>    // data accessor.
<span class="linenr">17: </span>    double &amp; element(unsigned i) const;
<span class="linenr">18: </span>
<span class="linenr">19: </span>    // Simple print function.
<span class="linenr">20: </span>    void print() const;
<span class="linenr">21: </span>
<span class="linenr">22: </span>  private:
<span class="linenr">23: </span>    unsigned length;
<span class="linenr">24: </span>    double * data;
<span class="linenr">25: </span>    void check_index(unsigned i) const;
<span class="linenr">26: </span>  };
<span class="linenr">27: </span>}
<span class="linenr">28: </span>#endif
</pre>
</div>

<p>
First note the macro guards, <code>#ifndef</code>, <code>#define</code>, and <code>#endif</code>, as well as the 
namespace, <code>vec</code>, wrapping the <code>class</code> declaration. Macro guards and namespaces 
were previously discussed when we initially introduced 
<a href="#sec-6-2">how to write header and implementation files</a>. 
</p>

<p>
Now, within the namespace, we've declared a class, <code>vector</code>, which 
contains <code>public</code> and <code>private</code> variables and function declarations. Private 
functions and variables may only be accessed through the public methods. This 
means if you created an instance of the class, <code>vector</code>, you would not be able 
to access the private variable directly. You could only call the <b>public 
member-functions</b>, which, in turn, may manipulate the 
<b>private member-variables</b>, or call the <b>private member-functions</b>. 
Splitting variables and functions into public and private helps to ensure 
that other libraries and programs use your class as intended.
</p>

<p>
Thus far, this class has 5 public member-functions, 2 private member-variables, 
and 1 private member-function. The first two member functions are special, 
the <b>constructor</b> and <b>destructor</b>, respectively. The constructor is called 
explicitly when you declare a new instance of this class, while the destructor 
is usually called implicitly when the object is deleted or when it goes out of 
scope.
</p>

<p>
Notice that the method for accessing elements of <code>vector</code> is called <code>element</code> 
and its return type is a <b>reference</b> (<a href="#sec-3-7-2">discussed previously</a>). This allows us 
to use this function on both the left side of assignment operators, i.e., to 
assign values to <code>vector</code> components, and on the right side of assignments, 
i.e., to treat it as the value of the component.
</p>

<p>
Finally, notice that some member function declarations end with the keyword, 
<code>const</code>. Functions with such a signature are not allowed to modify member 
variables, and they are also not allowed to call other non <code>const</code> member 
functions.
</p>
</div>
</div>

<div id="outline-container-sec-7-1-2" class="outline-4">
<h4 id="sec-7-1-2"><span class="section-number-4">7.1.2</span> The implementation file</h4>
<div class="outline-text-4" id="text-7-1-2">
<p>
Create the implementation file, <code>vector.cpp</code>:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include &lt;cstdlib&gt;
<span class="linenr"> 3: </span>#include "vector.h"
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>namespace vec {
<span class="linenr"> 6: </span>  vector::vector(unsigned len) {
<span class="linenr"> 7: </span>    this-&gt;length = len;
<span class="linenr"> 8: </span>    this-&gt;data = new double[len];
<span class="linenr"> 9: </span>    // Initialize data to zeros.
<span class="linenr">10: </span>    for(int i=0; i &lt; this-&gt;len(); i++) { this-&gt;data[i] = 0.0; }
<span class="linenr">11: </span>  }
<span class="linenr">12: </span>
<span class="linenr">13: </span>  vector::~vector() {
<span class="linenr">14: </span>    delete [] this-&gt;data;
<span class="linenr">15: </span>  }
<span class="linenr">16: </span>
<span class="linenr">17: </span>  unsigned vector::len() const {
<span class="linenr">18: </span>    return this-&gt;length;
<span class="linenr">19: </span>  }
<span class="linenr">20: </span>
<span class="linenr">21: </span>  double &amp; vector::element(unsigned i) const {
<span class="linenr">22: </span>    #ifndef NDEBUG
<span class="linenr">23: </span>    check_index(i);
<span class="linenr">24: </span>    #endif
<span class="linenr">25: </span>    return this-&gt;data[i];
<span class="linenr">26: </span>  }
<span class="linenr">27: </span>
<span class="linenr">28: </span>  void vector::print() const {
<span class="linenr">29: </span>    for(int i=0; i &lt; this-&gt;len(); i++) {
<span class="linenr">30: </span>      std::cout &lt;&lt; this-&gt;data[i] &lt;&lt; '\n';
<span class="linenr">31: </span>    }
<span class="linenr">32: </span>  }
<span class="linenr">33: </span>
<span class="linenr">34: </span>  void vector::check_index(unsigned i) const {
<span class="linenr">35: </span>    if (i &lt; 0 || i &gt;= this-&gt;length) {
<span class="linenr">36: </span>      std::cerr &lt;&lt; "ERROR: index, " &lt;&lt; i &lt;&lt; ", is out-of-bounds.\n"
<span class="linenr">37: </span>		&lt;&lt; "(valid indices are 0-" &lt;&lt; (this-&gt;length-1) &lt;&lt; ")\n";
<span class="linenr">38: </span>      exit(1);
<span class="linenr">39: </span>    }
<span class="linenr">40: </span>  }
<span class="linenr">41: </span>}
</pre>
</div>

<p>
Note that we again wrap the implementations in the same namespace as wrapped 
by the class declaration. Also observe how each member-function is prepended 
by <code>vector::</code>.
</p>

<p>
The keyword, <code>this</code>, is a pointer to the calling object. Writing, <code>this-&gt;</code>,
is equivalent to <code>(*this).</code>, and in fact, can be used for any pointer. Thus,
<code>this-&gt;length</code> is equivalent to <code>(*this).length</code>.
</p>

<p>
Observe how the private member function, <code>check_index</code>, is used in the 
public <code>element</code> accessor function. If this library is compiled with the 
flag, <code>-DNEDUBG</code>, then the check function will not be called. You could 
read this flag as "define no debug". Thus, when this flag is present, the 
debug function <code>check_index</code> is called whenever the element accessor is 
called. The <code>check_index</code> function simply checks if the provided index is 
out-of-bounds for the vector. If it is, an informative message is printed, 
and the program terminates prematurely by calling <code>exit(1)</code>. Such assertions 
with informative messages are a good practice, and will likely save you lots 
of headaches in the future.
</p>
</div>
</div>

<div id="outline-container-sec-7-1-3" class="outline-4">
<h4 id="sec-7-1-3"><span class="section-number-4">7.1.3</span> Example usage</h4>
<div class="outline-text-4" id="text-7-1-3">
<p>
Ok. Let's see some example usage, by creating a <code>main.cpp</code>, containing:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "vector.h"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    vec::vector v(5);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    std::cout &lt;&lt; "`v` has length = " &lt;&lt; v.len() &lt;&lt; "\n";
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    v.element(0) = -1.27;
<span class="linenr">10: </span>    v.element(3) = 3.1;
<span class="linenr">11: </span>
<span class="linenr">12: </span>    v.print();
<span class="linenr">13: </span>
<span class="linenr">14: </span>    v.element(5) = 1234.0;
<span class="linenr">15: </span>
<span class="linenr">16: </span>    return 0;
<span class="linenr">17: </span>}
</pre>
</div>

<p>
Let's first compile with our <code>check_index</code> debugger function in place:
</p>

<div class="org-src-container">

<pre class="src src-bash">g++ -c vector.cpp
g++ vector.o main.cpp
./a.out
</pre>
</div>

<p>
If successful, you should see:
</p>

<pre class="example">
`v` has length = 5
-1.27
0
0
3.1
0
ERROR: index, 5, is out-of-bounds.
(valid indices are 0-4)
</pre>

<p>
Now let's run without <code>check_index</code>:
</p>

<div class="org-src-container">

<pre class="src src-bash">g++ -DNDEBUG -c vector.cpp
g++ vector.o main.cpp
./a.out
</pre>
</div>

<p>
Upon running, you will likely see some extensive list of errors when 
the element beyond the array's length is attempted to be accessed. Again, 
by liberally sprinkling these sorts of assertions through your code, you 
will (sometimes) find debugging much easier. After you're fairly certain 
that your code is working, you can simply compile with <code>-DNEDUBG</code>.
</p>
</div>
</div>

<div id="outline-container-sec-7-1-4" class="outline-4">
<h4 id="sec-7-1-4"><span class="section-number-4">7.1.4</span> Operator overloading</h4>
<div class="outline-text-4" id="text-7-1-4">
<p>
The <code>v.element(i)</code> accessor is a bit clunky. We can replace this with the 
more natural, <code>v[i]</code>, by <b>overloading</b> the <code>[]</code> operator. Indeed,
 <a href="http://en.cppreference.com/w/cpp/language/operators">we can overload many</a> of the normal C++ operators, e.g. <code>+</code>, <code>-</code>, <code>=</code>, etc.
Some of these operators require more careful consideration when implementing 
class that utilizes dynamic memory allocation, such as our <code>vector</code> class.
</p>
</div>

<div id="outline-container-sec-7-1-4-1" class="outline-5">
<h5 id="sec-7-1-4-1"><span class="section-number-5">7.1.4.1</span> Overloading <code>operator[]</code></h5>
<div class="outline-text-5" id="text-7-1-4-1">
<p>
In the header file, replace the <code>element</code> function declaration with:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>// data accessor.
<span class="linenr">2: </span>double &amp; operator[](unsigned i) const;
</pre>
</div>

<p>
and in the implementation file, replace the <code>element</code> implementation with:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>double &amp; vector::operator[](unsigned i) const {
<span class="linenr">2: </span>  #ifndef NDEBUG
<span class="linenr">3: </span>  check_index(i);
<span class="linenr">4: </span>  #endif
<span class="linenr">5: </span>  return this-&gt;data[i];
<span class="linenr">6: </span>}
</pre>
</div>

<p>
Just think of <code>operator[]</code> as the new name of the function, <code>element</code>. We 
can now use the overloaded operator just like how we would use the <code>[]</code> for 
operator for accessing array components, expect now our overloaded operator 
function is called instead.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>v[0] = -1.27;
<span class="linenr">2: </span>v[3] = 3.1;
</pre>
</div>

<p>
Compile and run:
</p>

<div class="org-src-container">

<pre class="src src-bash">g++ -c vector.cpp &amp;&amp; g++ vector.o main.cpp &amp;&amp; ./a.out
</pre>
</div>

<p>
and you should see:
</p>

<pre class="example">
-1.27
0
0
3.1
0
</pre>

<p>
just like before.
</p>
</div>
</div>

<div id="outline-container-sec-7-1-4-2" class="outline-5">
<h5 id="sec-7-1-4-2"><span class="section-number-5">7.1.4.2</span> Overloading <code>operator=</code></h5>
<div class="outline-text-5" id="text-7-1-4-2">
<p>
Let's overload the <code>=</code> operator so we can assign one vector to another. 
We'll write in a way such that the vector on the left hand side is 
overwritten by the one on the right.
</p>

<p>
Let's add a declaration to the header file,
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>// assignment operator.
<span class="linenr">2: </span>vector &amp; operator=(const vector &amp; src);
</pre>
</div>

<p>
and let's add to the implementation file,
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>vector &amp; vector::operator=(const vector &amp; src) {
<span class="linenr"> 2: </span>  // Delete the old data.
<span class="linenr"> 3: </span>  delete [] this-&gt;data;
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>  // Initialize the new data.
<span class="linenr"> 6: </span>  this-&gt;length = src.len();
<span class="linenr"> 7: </span>  this-&gt;data = new double[this-&gt;len()];
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>  // Copy over the new data.
<span class="linenr">10: </span>  for(int i=0; i &lt; this-&gt;len(); i++) {
<span class="linenr">11: </span>    this-&gt;data[i] = src[i];
<span class="linenr">12: </span>  }
<span class="linenr">13: </span>
<span class="linenr">14: </span>  return *this;
<span class="linenr">15: </span>}
</pre>
</div>

<p>
Now, let's assume the <code>vector</code> instance, <code>v</code>, from above is still defined, and
we'll create a new vector:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vec::vector w(14);
<span class="linenr">2: </span>w = v;
<span class="linenr">3: </span>w.print();
</pre>
</div>

<p>
This should print, 
</p>

<pre class="example">
-1.27
0
0
3.1
0
</pre>

<p>
Notice that <code>w</code> is intially defined to be of length <code>14</code>, but this is 
overwritten, and its new length is the length of <code>v</code>. Also note that all of
<code>w</code>'s old data is deleted.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-7-1-5" class="outline-4">
<h4 id="sec-7-1-5"><span class="section-number-4">7.1.5</span> The copy constructor</h4>
<div class="outline-text-4" id="text-7-1-5">
<p>
It may be tempting at this point to attempt to initialize <code>w</code> from <code>v</code>
directly:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vec::vector w = v;
</pre>
</div>

<p>
If you attempt this currently, you will see all sorts of errors. This is 
because this type of intialization does not call the assignment operator. 
It calls the <b>copy constructor</b>. The assignment operator is only called 
when the object has already been intialized. Writing the previous line of 
code is essentially equivalent to
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vec::vector w(v);
</pre>
</div>

<p>
In other words, the constructor is called with the existing vector, <code>v</code>, as
the argument, but we have not written a constructor yet with such a call 
signature.
</p>

<p>
The constructor can be overloaded, i.e., we can write multiple versions of the 
constructor function, and the one that matches the correct call signature will 
be used. This function overloading behavior actually applies to all functions 
in C++.
</p>

<p>
Let's add the copy constructor declaration to the header file:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>// Copy constructor.
<span class="linenr">2: </span>vector(const vector &amp; src);
</pre>
</div>

<p>
and let's add its implementation:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vector::vector(const vector &amp; src) {
<span class="linenr">2: </span>  this-&gt;length = src.len();
<span class="linenr">3: </span>  this-&gt;data = new double[this-&gt;len()];
<span class="linenr">4: </span>
<span class="linenr">5: </span>  // Copy over the data.
<span class="linenr">6: </span>  for(int i=0; i &lt; this-&gt;len(); i++) {
<span class="linenr">7: </span>    this-&gt;data[i] = src[i];
<span class="linenr">8: </span>  }
<span class="linenr">9: </span>}
</pre>
</div>

<p>
Now we compile and run something like:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vec::vector w = v;
<span class="linenr">2: </span>w.print();
</pre>
</div>

<p>
we will see:
</p>

<pre class="example">
-1.27
0
0
3.1
0
</pre>
</div>
</div>

<div id="outline-container-sec-7-1-6" class="outline-4">
<h4 id="sec-7-1-6"><span class="section-number-4">7.1.6</span> Friend functions</h4>
<div class="outline-text-4" id="text-7-1-6">
<p>
Non-member functions may access private member variables and private member 
functions of by labeling them as <code>friend</code>. This is useful in situations where 
it is not clear that function should be "called on" an object, i.e. 
<code>object.method(params)</code>. Friend functions should be declared in the class 
declaration, but their implementation is not prepended with <code>class::</code>, which 
is necessary for member functions.
</p>
</div>

<div id="outline-container-sec-7-1-6-1" class="outline-5">
<h5 id="sec-7-1-6-1"><span class="section-number-5">7.1.6.1</span> Overloading <code>operator*</code></h5>
<div class="outline-text-5" id="text-7-1-6-1">
<p>
As an example, we'll overload <code>operator*</code> to implement scalar multiplication.
</p>

<p>
Because scalar multiplication should commute, let's add the following
two declarations to our header file:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>friend vector operator*(const vector &amp; v, double s);
<span class="linenr">2: </span>friend vector operator*(double s, const vector &amp; v);
</pre>
</div>

<p>
Let's implement the first by adding to the declaration file:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vector operator*(const vector &amp; v, double s) {
<span class="linenr">2: </span>    // Copy v to start.
<span class="linenr">3: </span>    vector result = v;
<span class="linenr">4: </span>    // Then multiply all entries by scalar, s.
<span class="linenr">5: </span>    for(int i=0; i &lt; v.len(); i++) {
<span class="linenr">6: </span>	result[i] *= s;
<span class="linenr">7: </span>    }
<span class="linenr">8: </span>    return result;
<span class="linenr">9: </span>}
</pre>
</div>

<p>
Observe how we didn't prepend <code>vector::</code> before <code>operator*</code> because 
these are <code>friend</code> functions.
</p>

<p>
Now, we can use the first implementation to achieve the second:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>vector operator*(double s, const vector &amp; v) {
<span class="linenr">2: </span>    return v*s;
<span class="linenr">3: </span>}
</pre>
</div>

<p>
And let's try it out:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "vector.h"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    vec::vector v(5);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    v[0] = -1.27;
<span class="linenr"> 8: </span>    v[3] = 3.1;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    vec::vector w = 2*v;
<span class="linenr">11: </span>
<span class="linenr">12: </span>    w.print();
<span class="linenr">13: </span>
<span class="linenr">14: </span>    std::cout &lt;&lt; "\n";
<span class="linenr">15: </span>
<span class="linenr">16: </span>    w = w*0.5;
<span class="linenr">17: </span>
<span class="linenr">18: </span>    w.print();
<span class="linenr">19: </span>
<span class="linenr">20: </span>    return 0;
<span class="linenr">21: </span>}
</pre>
</div>

<p>
prints:
</p>

<pre class="example">
-2.54
0
0
6.2
0

-1.27
0
0
3.1
0
</pre>

<p>
Other binary arithmetic operators could also be implements as <code>friend</code> 
functions, e.g., vector addition and subtraction and component-wise 
multiplication and division. Component-wise multiplication would overload 
<code>operator*</code> for a third time but would accept two vectors as function 
arguments.
</p>
</div>
</div>

<div id="outline-container-sec-7-1-6-2" class="outline-5">
<h5 id="sec-7-1-6-2"><span class="section-number-5">7.1.6.2</span> Overloading <code>operator&lt;&lt;</code></h5>
<div class="outline-text-5" id="text-7-1-6-2">
<p>
We may overload <code>operator&lt;&lt;</code> to send things to the output stream. This 
is a more C++ way to print than our current <code>print</code> function. We overload
this operator by adding the following <code>friend</code> declaration to the header:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>friend std::ostream &amp; operator&lt;&lt;(std::ostream &amp; outs, const vector &amp; v);
</pre>
</div>

<p>
Note that the <code>ostream</code> object belongs to the <code>std</code> namespace. Next, we
add to the implementation file:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>std::ostream &amp; operator&lt;&lt;(std::ostream &amp; outs, const vector &amp; v) {
<span class="linenr">2: </span>    for(int i=0; i &lt; v.len(); i++) {
<span class="linenr">3: </span>	outs &lt;&lt; v.data[i] &lt;&lt; "\n";
<span class="linenr">4: </span>    }
</pre>
</div>

<p>
So now we stream the vector to <code>std::cout</code> just as we do for printing 
numbers and strings to the screen:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "vector.h"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    vec::vector v(5);
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    v[0] = -1.27;
<span class="linenr"> 8: </span>    v[3] = 3.1;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    std::cout &lt;&lt; v;
<span class="linenr">11: </span>
<span class="linenr">12: </span>    return 0;
<span class="linenr">13: </span>}
</pre>
</div>

<p>
which prints
</p>

<pre class="example">
-1.27
0
0
3.1
0
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> Templating: a matrix class</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Template classes allow you to generalize your classes. We will introduce the 
concept of templating by creating a templated matrix class. Below is a bare-bones 
template class for a matrix type. Note that the implementations for templates 
must all go in the header file; they cannot be split into seperate 
implementation files.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#ifndef MATRIX_H
<span class="linenr"> 2: </span>#define MATRIX_H
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>#include &lt;iostream&gt;
<span class="linenr"> 5: </span>#include &lt;cstdlib&gt;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>namespace mtx {
<span class="linenr"> 8: </span>    template&lt;class T&gt;
<span class="linenr"> 9: </span>    class matrix {
<span class="linenr">10: </span>    public:
<span class="linenr">11: </span>	// Default empty constructor.
<span class="linenr">12: </span>	matrix() {}
<span class="linenr">13: </span>
<span class="linenr">14: </span>	// Constructor from matrix dimensions.
<span class="linenr">15: </span>	matrix(int m, int n) {
<span class="linenr">16: </span>	    this-&gt;m = m; this-&gt;n = n;
<span class="linenr">17: </span>	    this-&gt;data = new T[m*n];
<span class="linenr">18: </span>	    // Initialize to zeros.
<span class="linenr">19: </span>	    for(int i=0; i &lt; m*n; i++) this-&gt;data[i] = T(0);
<span class="linenr">20: </span>	}
<span class="linenr">21: </span>
<span class="linenr">22: </span>	// Copy constructor.
<span class="linenr">23: </span>	matrix(const matrix &amp; src) : matrix(src.m, src.n) {
<span class="linenr">24: </span>	    for(int i=0; i &lt; m; i++) {
<span class="linenr">25: </span>		for(int j=0; j &lt; n; j++) {
<span class="linenr">26: </span>		    (*this)(i,j) = src(i,j);
<span class="linenr">27: </span>		}
<span class="linenr">28: </span>	    }
<span class="linenr">29: </span>	}
<span class="linenr">30: </span>
<span class="linenr">31: </span>	// Destructor.
<span class="linenr">32: </span>	~matrix() { delete [] this-&gt;data; }
<span class="linenr">33: </span>
<span class="linenr">34: </span>	int n_rows() const { return this-&gt;m; }
<span class="linenr">35: </span>	int n_cols() const { return this-&gt;n; }
<span class="linenr">36: </span>
<span class="linenr">37: </span>	// Element accessor.
<span class="linenr">38: </span>	T &amp; operator()(int i, int j) const {
<span class="linenr">39: </span>	    #ifndef NDEBUG
<span class="linenr">40: </span>	    check_indices(i,j);
<span class="linenr">41: </span>	    #endif
<span class="linenr">42: </span>
<span class="linenr">43: </span>	    // Data stored in row-major.
<span class="linenr">44: </span>	    int k = i*this-&gt;n + j;
<span class="linenr">45: </span>
<span class="linenr">46: </span>	    return this-&gt;data[k];
<span class="linenr">47: </span>	}
<span class="linenr">48: </span>    protected:
<span class="linenr">49: </span>	T * data;
<span class="linenr">50: </span>	int m; // n_rows
<span class="linenr">51: </span>	int n; // n_cols
<span class="linenr">52: </span>	void check_indices(int i, int j) const {
<span class="linenr">53: </span>	    if (i &lt; 0 || i &gt;= this-&gt;m) {
<span class="linenr">54: </span>		std::cerr &lt;&lt; "Invalid row index, " &lt;&lt; i &lt;&lt; ".\n"
<span class="linenr">55: </span>			  &lt;&lt; "Valid row indices are: 0-" &lt;&lt; (this-&gt;m-1)
<span class="linenr">56: </span>			  &lt;&lt; ".\n";
<span class="linenr">57: </span>		exit(1);
<span class="linenr">58: </span>	    }
<span class="linenr">59: </span>	    if (j &lt; 0 || j &gt;= this-&gt;n) {
<span class="linenr">60: </span>		std::cerr &lt;&lt; "Invalid column index, " &lt;&lt; j &lt;&lt; ".\n"
<span class="linenr">61: </span>			  &lt;&lt; "Valid column indices are: 0-" &lt;&lt; (this-&gt;n-1)
<span class="linenr">62: </span>			  &lt;&lt; ".\n";
<span class="linenr">63: </span>		exit(1);
<span class="linenr">64: </span>	    }
<span class="linenr">65: </span>	}
<span class="linenr">66: </span>    };
<span class="linenr">67: </span>}
<span class="linenr">68: </span>
<span class="linenr">69: </span>#endif
</pre>
</div>

<p>
Observe how the class declaration begins with the statement, <code>template&lt;class T&gt;</code>.
When new instances of the class, <code>matrix</code>, are instantiated, the type, <code>T</code>, must 
be specified. Notice that the private variable now holds a pointer to type, <code>T</code>, 
and the element accessor returns a reference to to type, <code>T</code>. Compare this to 
our previous <code>vector</code> class where each vector instance held type, <code>double</code>.
</p>

<p>
Also notice that the copy constructor uses something called an argument list. 
We've used it to call the initial constructor before proceeding with the copying
of components from the <code>matrix</code> instance, <code>src</code>. To use this type of syntax (i.e., 
initializer lists) you may have to compiel with the flag <code>-std=c++11</code>, e.g.,
<code>g++ -std=c++11 main.cpp</code>.
</p>

<p>
Finally, observe that rather the keyword, <code>private</code>, we have used the keyword 
<code>protected</code>. This will allow inherited classes to use the private member variables 
and functions. We will talk about inheritance later, but for now, it essentially
the same as marking these things as <code>private</code>.
</p>

<p>
Here is some example usage:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "matrix.h"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    mtx::matrix&lt;float&gt;  A(10, 10);
<span class="linenr"> 6: </span>    mtx::matrix&lt;double&gt; B(10, 12);
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    A(0,0) = 3.14;
<span class="linenr"> 9: </span>    B(2,4) = -2*A(0,0);
<span class="linenr">10: </span>
<span class="linenr">11: </span>    std::cout &lt;&lt; A(0,0) &lt;&lt; "\n";
<span class="linenr">12: </span>    std::cout &lt;&lt; B(2,4) &lt;&lt; "\n";
<span class="linenr">13: </span>
<span class="linenr">14: </span>    mtx::matrix&lt;double&gt; C = B;
<span class="linenr">15: </span>    mtx::matrix&lt;bool&gt; D(3,3);
<span class="linenr">16: </span>
<span class="linenr">17: </span>    std::cout &lt;&lt; C(2,4) &lt;&lt; "\n";
<span class="linenr">18: </span>    std::cout &lt;&lt; D(0,0) &lt;&lt; "\n";
<span class="linenr">19: </span>
<span class="linenr">20: </span>    C(0,12);
<span class="linenr">21: </span>
<span class="linenr">22: </span>    return 0;
<span class="linenr">23: </span>}
</pre>
</div>

<p>
Outputs:
</p>

<pre class="example">
3.14
-6.28
-6.28
0
Invalid column index, 12.
Valid column indices are: 0-11.
</pre>
</div>

<div id="outline-container-sec-7-2-1" class="outline-4">
<h4 id="sec-7-2-1"><span class="section-number-4">7.2.1</span> Overloading <code>operator*</code></h4>
<div class="outline-text-4" id="text-7-2-1">
<p>
Let us overload <code>operator*</code> to implement matrix multiplication. It would also
make sense to overload <code>operator*</code> with other call signatures to implement scalar 
multiplication or vector broadcasting, but for now we will just stick with 
matrix multiplication.
</p>

<p>
Add the following two non-friend, non-member functions. They should be defined 
just after the class definition, but they should remain in the body of namespace,
<code>mtx</code>.
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>template&lt;class T&gt;
<span class="linenr"> 2: </span>matrix&lt;T&gt; operator*(const matrix&lt;T&gt; &amp; L, const matrix&lt;T&gt; &amp; R) {
<span class="linenr"> 3: </span>    #ifndef NDEBUG
<span class="linenr"> 4: </span>    check_sizes_for_matmul(L, R);
<span class="linenr"> 5: </span>    #endif
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    matrix&lt;T&gt; P(L.n_rows(), R.n_cols());
<span class="linenr"> 8: </span>    for(int i=0; i &lt; L.n_rows(); i++) {
<span class="linenr"> 9: </span>	for(int j=0; j &lt; R.n_cols(); j++) {
<span class="linenr">10: </span>	    // Inner product between row `i` of matrix, `L`
<span class="linenr">11: </span>	    // and column `j` of matrix, `R`.
<span class="linenr">12: </span>	    for(int k=0; k &lt; L.n_cols(); k++) {
<span class="linenr">13: </span>		P(i,j) += L(i,k)*R(k,j);
<span class="linenr">14: </span>	    }
<span class="linenr">15: </span>	}
<span class="linenr">16: </span>    }
<span class="linenr">17: </span>
<span class="linenr">18: </span>    return P;
<span class="linenr">19: </span>}
<span class="linenr">20: </span>
<span class="linenr">21: </span>template&lt;class T&gt;
<span class="linenr">22: </span>void check_sizes_for_matmul(const matrix&lt;T&gt; &amp; L, const matrix&lt;T&gt; &amp; R) {
<span class="linenr">23: </span>    if (L.n_cols() != R.n_rows()) {
<span class="linenr">24: </span>	std::cerr &lt;&lt; "Size mismatch for matrix multiplication.\n"
<span class="linenr">25: </span>		  &lt;&lt; "Left matrix has " &lt;&lt; L.n_cols() &lt;&lt; " cols, but\n"
<span class="linenr">26: </span>		  &lt;&lt; "right matrix has " &lt;&lt; R.n_rows() &lt;&lt; " rows.\n";
<span class="linenr">27: </span>	exit(1);
<span class="linenr">28: </span>    }
<span class="linenr">29: </span>}
</pre>
</div>

<p>
Note that because we've chosen to implement these functions as non-member 
and non-friend, we must prefix the function definitions with 
<code>template&lt;class T&gt;</code>. This isn't necessary when the functions were declared 
inside of the class body (i.e., member or friend functions) since the class 
declaration already begins with <code>template&lt;class T&gt;</code>.
</p>

<p>
We've added a simple matrix multiplcation function above and a debugger 
functions to ensure that if two matrices are multiplied, that it is well-
defined to do so. Otherwise, we print an error message and abort, as with 
the element accessor function. We've also wrapped the debugger function 
with compiler macros, so that it can be left out if we choose to do so.
</p>

<p>
Here is some example usage:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "matrix.h"
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>int main() {
<span class="linenr"> 5: </span>    mtx::matrix&lt;double&gt; A(2,2);
<span class="linenr"> 6: </span>    mtx::matrix&lt;double&gt; B(2,3);
<span class="linenr"> 7: </span>
<span class="linenr"> 8: </span>    A(0,0) = A(0,1) = A(1,0) = 1; A(1,1) = -1;
<span class="linenr"> 9: </span>
<span class="linenr">10: </span>    B(0,0) = B(1,0) = 1;
<span class="linenr">11: </span>    B(0,1) = B(1,1) = -1;
<span class="linenr">12: </span>    B(0,2) = B(1,2) = 3;
<span class="linenr">13: </span>
<span class="linenr">14: </span>
<span class="linenr">15: </span>    mtx::matrix&lt;double&gt; C = A*B;
<span class="linenr">16: </span>
<span class="linenr">17: </span>    for(int i=0; i &lt; C.n_rows(); i++) {
<span class="linenr">18: </span>	for(int j=0; j &lt; C.n_cols(); j++) {
<span class="linenr">19: </span>	    std::cout &lt;&lt; C(i,j);
<span class="linenr">20: </span>	    if (j &lt; C.n_cols()-1)
<span class="linenr">21: </span>		std::cout &lt;&lt; ", ";
<span class="linenr">22: </span>	}
<span class="linenr">23: </span>	std::cout &lt;&lt; "\n";
<span class="linenr">24: </span>    }
<span class="linenr">25: </span>
<span class="linenr">26: </span>    B*A;
<span class="linenr">27: </span>
<span class="linenr">28: </span>    return 0;
<span class="linenr">29: </span>}
</pre>
</div>

<p>
Output:
</p>

<pre class="example">
2, -2, 6
0, 0, 0
Size mismatch for matrix multiplication.
Left matrix has 3 cols, but
right matrix has 2 rows.
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3"><span class="section-number-3">7.3</span> Inheritance</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Often classes have a natural, hierarchical structure.
For example, a row or column vector could be seen as natural
"subclass" of the matrix class. So, supposing we had only 
written the matrix class, it would be nice if we could write 
a row or column vector class that inherited many of the properties 
of the parent matrix class, but with additional properties, 
unique to the vector classes. This is what inheritance may allow 
us to do.
</p>

<p>
Let's create another couple of vector classes, called <code>rowvec</code> and
<code>colvec</code> in a file called <code>vectors.h</code>:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#ifndef VECTORS_H
<span class="linenr"> 2: </span>#define VECTORS_H
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span>#include "matrix.h"
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>namespace vec {
<span class="linenr"> 7: </span>    // Row vector class inherits from the matrix class.
<span class="linenr"> 8: </span>    template&lt;class T&gt;
<span class="linenr"> 9: </span>    class rowvec : public mtx::matrix&lt;T&gt; {
<span class="linenr">10: </span>    public:
<span class="linenr">11: </span>	// Constructor.
<span class="linenr">12: </span>	rowvec(int n) : mtx::matrix&lt;T&gt;(1, n) {}
<span class="linenr">13: </span>
<span class="linenr">14: </span>	// A length function.
<span class="linenr">15: </span>	int len() const { return this-&gt;n_cols(); }
<span class="linenr">16: </span>
<span class="linenr">17: </span>	// Accessors.
<span class="linenr">18: </span>	T &amp; operator()(int i) const { return mtx::matrix&lt;T&gt;::operator()(0, i); }
<span class="linenr">19: </span>	// Add [] as a possibility, too.
<span class="linenr">20: </span>	T &amp; operator[](int i) const { return (*this)(i); }
<span class="linenr">21: </span>    };
<span class="linenr">22: </span>
<span class="linenr">23: </span>    // Column vector class also inherits from the matrix class.
<span class="linenr">24: </span>    template&lt;class T&gt;
<span class="linenr">25: </span>    class colvec : public mtx::matrix&lt;T&gt; {
<span class="linenr">26: </span>    public:
<span class="linenr">27: </span>	// Constructor.
<span class="linenr">28: </span>	colvec(int n) : mtx::matrix&lt;T&gt;(n, 1) {}
<span class="linenr">29: </span>
<span class="linenr">30: </span>	// A length function.
<span class="linenr">31: </span>	int len() const { return this-&gt;n_rows(); }
<span class="linenr">32: </span>
<span class="linenr">33: </span>	// Accessor.
<span class="linenr">34: </span>	T &amp; operator()(int i) const { return mtx::matrix&lt;T&gt;::operator()(i, 0); }
<span class="linenr">35: </span>	// Add [] as a possibility, too.
<span class="linenr">36: </span>	T &amp; operator[](int i) const { return (*this)(i); }
<span class="linenr">37: </span>    };
<span class="linenr">38: </span>}
<span class="linenr">39: </span>
<span class="linenr">40: </span>#endif
</pre>
</div>

<p>
We have defined two classes in the <code>vec</code> namespace, <code>rowvec</code> and <code>colvec</code>.
Notice that the declaration of the <code>rowvec</code> class is slightly augmented,
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr">1: </span>class rowvec : public mtx::matrix&lt;T&gt; {
<span class="linenr">2: </span>// ...
<span class="linenr">3: </span>};
</pre>
</div>

<p>
This says that the <code>rowvec</code> class inherits all the methods and
variables defined for the <code>matrix</code> class. The keyword <code>protected</code>, 
rather than <code>private</code> in the <code>matrix</code> class allows derived classes 
access to these variables and functions. The keyword, <code>public</code>, in 
the class declaration above signals that every <code>rowvec&lt;T&gt;</code> instance 
may be cast as a <code>matrix&lt;T&gt;</code> instance. This means that functions (such
as our <code>operator*</code> in the <code>mtx</code> namespace) which expect <code>matrix</code> types
in argument, can also now accept <code>rowvec</code> types: <code>rowvec</code> instances 
will be cast as <code>matrix</code> instances when possible.
</p>


<p>
Next, observe that the constructor simply calls the parent class 
constructor, with an argument of <code>1</code> for the number of rows. We also 
add a <code>len()</code> function which returns `n<sub>cols</sub>()`, calling the parent 
class function. <code>len()</code> is more natural for a vector class.
</p>

<p>
Finally, <code>operator()</code> is overwritten so that only a single argument is 
necessary. In the body, we simply call the parent class method. We also 
add <code>operator[]</code>, which duplicates the functionality of <code>operator()</code>.
</p>

<p>
Notice that any other methods that exist for the parent class, <code>matrix</code>, 
have been inherited. For example, it is not necessary to write a new 
destructor function since this already exists for the parent and the 
functionality is the same.
</p>

<p>
In the same, <code>vec</code>, namespace we have declared a <code>colvec</code> class which 
is analogous to the <code>rowvec</code> class except with the dimensions swapped.
</p>

<p>
Let's check out an example:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "matrix.h"
<span class="linenr"> 3: </span>#include "vectors.h"
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>int main() {
<span class="linenr"> 6: </span>    vec::rowvec&lt;float&gt; x(5);
<span class="linenr"> 7: </span>    vec::colvec&lt;float&gt; y(5);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    for(int i=0; i &lt; x.len(); i++) {
<span class="linenr">10: </span>	x(i) = i;
<span class="linenr">11: </span>	y[i] = -i; // elements may be accessed with either operator.
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    // `rowvec` and `colvec` inherit from `matrix`,
<span class="linenr">15: </span>    // so `operator*` is well-defined if the shapes
<span class="linenr">16: </span>    // align, which always do for `rowvec` * `colvec`.
<span class="linenr">17: </span>    // However, the result is a `matrix` object.
<span class="linenr">18: </span>    mtx::matrix&lt;float&gt; a = x*y;
<span class="linenr">19: </span>
<span class="linenr">20: </span>    std::cout &lt;&lt; a.n_rows() &lt;&lt; ", " &lt;&lt; a.n_cols()
<span class="linenr">21: </span>	      &lt;&lt; " ... " &lt;&lt; a(0,0) &lt;&lt; "\n";
<span class="linenr">22: </span>
<span class="linenr">23: </span>    return 0;
<span class="linenr">24: </span>}
</pre>
</div>

<p>
This prints:
</p>

<pre class="example">
1, 1 ... -30
</pre>

<p>
So <code>operator*</code> works by casting both the <code>rowvec</code> and <code>colvec</code> arguments 
as <code>matrix</code> types. The dimensions of these matrices match for matrix 
multiplication and the resulting 1x1 matrix is returned. Let's overwrite
this behavior to return a scalar instead of a matrix when the operation,
<code>rowvec*colvec</code> is performed. Add the inside the <code>vec</code> namespace but outside 
the class declarations:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>// Overwrite the matrix inherited `operator*`
<span class="linenr"> 2: </span>// so that a scalar is returned when a `rowvec` and
<span class="linenr"> 3: </span>// `colvec` are multiplied.
<span class="linenr"> 4: </span>template&lt;class T&gt;
<span class="linenr"> 5: </span>T operator*(const rowvec&lt;T&gt; &amp; x, const colvec&lt;T&gt; &amp; y) {
<span class="linenr"> 6: </span>    // Use the inherited matrix operator defined in the `mtx` namespace.
<span class="linenr"> 7: </span>    mtx::matrix&lt;T&gt; a = mtx::operator*(x,y);
<span class="linenr"> 8: </span>    // Grab the only entry.
<span class="linenr"> 9: </span>    T z = a(0,0);
<span class="linenr">10: </span>    // And return it.
<span class="linenr">11: </span>    return z;
<span class="linenr">12: </span>}
</pre>
</div>

<p>
Observe that we can call the <code>operator*</code> function in the <code>mtx</code> namespace,
just like any other function. Now, the product between a <code>rowvec</code> and a <code>colvec</code>
is more natural:
</p>

<div class="org-src-container">

<pre class="src src-cpp"><span class="linenr"> 1: </span>#include &lt;iostream&gt;
<span class="linenr"> 2: </span>#include "matrix.h"
<span class="linenr"> 3: </span>#include "vectors.h"
<span class="linenr"> 4: </span>
<span class="linenr"> 5: </span>int main() {
<span class="linenr"> 6: </span>    vec::rowvec&lt;float&gt; x(5);
<span class="linenr"> 7: </span>    vec::colvec&lt;float&gt; y(5);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>    for(int i=0; i &lt; x.len(); i++) {
<span class="linenr">10: </span>	x(i) = i;
<span class="linenr">11: </span>	y[i] = -i; // elements may be accessed with either operator.
<span class="linenr">12: </span>    }
<span class="linenr">13: </span>
<span class="linenr">14: </span>    float a = x*y;
<span class="linenr">15: </span>    std::cout &lt;&lt; a &lt;&lt; "\n";
<span class="linenr">16: </span>
<span class="linenr">17: </span>    return 0;
<span class="linenr">18: </span>}
</pre>
</div>

<p>
Output:
</p>

<pre class="example">
-30
</pre>

</div>
</div>
</div>
</div>
</div>
</body>
</html>
